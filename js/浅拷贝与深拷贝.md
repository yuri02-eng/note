# JavaScript 深拷贝与浅拷贝完全指南

## 一、核心概念对比

| 特性         | 浅拷贝 (Shallow Copy)               | 深拷贝 (Deep Copy)                   |
| ------------ | ----------------------------------- | ------------------------------------- |
| **定义**     | 复制对象的顶层属性                  | 递归复制对象的所有层级属性            |
| **引用处理** | 嵌套对象保持引用关系                | 嵌套对象创建全新副本                  |
| **内存占用** | 较少                                | 较多                                  |
| **性能**     | 较快                                | 较慢（尤其对大型对象）                |
| **修改影响** | 修改嵌套对象会影响原对象            | 修改嵌套对象不影响原对象              |
| **适用场景** | 简单对象、不需要修改嵌套属性的情况  | 复杂对象、需要完全独立副本的情况      |

## 二、浅拷贝实现方法

### 1. 扩展运算符 (...)

```javascript
const original = { a: 1, b: { c: 2 } };
const shallowCopy = { ...original };

// 修改浅拷贝的嵌套属性会影响原对象
shallowCopy.b.c = 3;
console.log(original.b.c); // 3
```

### 2. Object.assign()

```javascript
const original = { a: 1, b: { c: 2 } };
const shallowCopy = Object.assign({}, original);

// 修改浅拷贝的嵌套属性会影响原对象
shallowCopy.b.c = 3;
console.log(original.b.c); // 3
```

### 3. Array.prototype.slice()

```javascript
const original = [1, 2, { a: 3 }];
const shallowCopy = original.slice();

// 修改浅拷贝的嵌套对象会影响原数组
shallowCopy[2].a = 4;
console.log(original[2].a); // 4
```

### 4. Array.prototype.concat()

```javascript
const original = [1, 2, { a: 3 }];
const shallowCopy = [].concat(original);

// 修改浅拷贝的嵌套对象会影响原数组
shallowCopy[2].a = 4;
console.log(original[2].a); // 4
```

### 5. Array.from()

```javascript
const original = [1, 2, { a: 3 }];
const shallowCopy = Array.from(original);

// 修改浅拷贝的嵌套对象会影响原数组
shallowCopy[2].a = 4;
console.log(original[2].a); // 4
```

## 三、深拷贝实现方法

### 1. JSON.parse(JSON.stringify())

```javascript
const original = { 
  a: 1, 
  b: { c: 2 },
  d: new Date(),
  e: [1, 2, 3],
  f: () => console.log('test')
};

const deepCopy = JSON.parse(JSON.stringify(original));

// 修改深拷贝的嵌套属性不会影响原对象
deepCopy.b.c = 3;
console.log(original.b.c); // 2

// 局限性：
console.log(deepCopy.d); // 字符串而不是Date对象
console.log(deepCopy.f); // undefined（函数被忽略）
```

**存在缺陷**:忽略undefined,忽略Symbol,忽略Function,Date变成字符串，无法处理循环引用

### 2. 递归实现

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // 处理基本类型和null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 处理日期对象
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则表达式
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    const cloneArr = [];
    hash.set(obj, cloneArr);
    obj.forEach((item, index) => {
      cloneArr[index] = deepClone(item, hash);
    });
    return cloneArr;
  }
  
  // 处理普通对象
  const cloneObj = Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, cloneObj);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  
  return cloneObj;
}

// 使用示例
const original = { 
  a: 1, 
  b: { c: 2 },
  d: new Date(),
  e: [1, 2, 3],
  f: function() { console.log('test'); }
};

const deepCopy = deepClone(original);

// 修改深拷贝的嵌套属性不会影响原对象
deepCopy.b.c = 3;
console.log(original.b.c); // 2

// 函数被正确复制
deepCopy.f(); // 'test'
```

### 3. 使用第三方库

#### Lodash

```javascript
const _ = require('lodash');

const original = { a: 1, b: { c: 2 } };
const deepCopy = _.cloneDeep(original);

// 修改深拷贝的嵌套属性不会影响原对象
deepCopy.b.c = 3;
console.log(original.b.c); // 2
```

#### jQuery

```javascript
const original = { a: 1, b: { c: 2 } };
const deepCopy = $.extend(true, {}, original);

// 修改深拷贝的嵌套属性不会影响原对象
deepCopy.b.c = 3;
console.log(original.b.c); // 2
```

## 四、深拷贝注意事项

### 1. 循环引用问题

```javascript
const objA = { name: 'A' };
const objB = { name: 'B' };
objA.child = objB;
objB.parent = objA; // 循环引用

// JSON方法会报错
// JSON.parse(JSON.stringify(objA)); // TypeError

// 使用递归方法（带WeakMap处理循环引用）
const deepCopy = deepClone(objA);
console.log(deepCopy.child.parent === deepCopy); // true
```

### 2. 特殊对象处理

| 对象类型       | JSON方法 | 递归实现 | Lodash |
| -------------- | -------- | -------- | ------ |
| **Date**       | 转字符串 | 支持     | 支持   |
| **RegExp**     | 转空对象 | 支持     | 支持   |
| **Function**   | 忽略     | 支持     | 支持   |
| **Map/Set**    | 忽略     | 需扩展   | 支持   |
| **Symbol**     | 忽略     | 需扩展   | 支持   |
| **原型链**     | 丢失     | 保留     | 保留   |
| **不可枚举属性** | 忽略     | 忽略     | 支持   |

### 3. 性能考虑

```javascript
// 性能测试：深拷贝10,000个对象的数组
const largeArray = Array(10000).fill().map((_, i) => ({
  id: i,
  data: { value: Math.random() }
}));

// JSON方法
console.time('JSON');
const jsonCopy = JSON.parse(JSON.stringify(largeArray));
console.timeEnd('JSON'); // ~50ms

// 递归方法
console.time('Recursive');
const recursiveCopy = deepClone(largeArray);
console.timeEnd('Recursive'); // ~150ms

// Lodash方法
console.time('Lodash');
const lodashCopy = _.cloneDeep(largeArray);
console.timeEnd('Lodash'); // ~100ms
```

## 五、深拷贝优化策略

### 1. 结构化克隆算法

现代浏览器支持的结构化克隆算法（用于Web Workers）：

**structuredClone**现代API,无法拷贝函数，无法拷贝Error对象/Dom节点

```javascript
// 浏览器环境
const original = { a: 1, b: { c: 2 } };
const deepCopy = structuredClone(original);

// Node.js环境（v17+）
const { structuredClone } = require('util');
const deepCopy = structuredClone(original);
```

### 2. 性能优化技巧

```javascript
function optimizedDeepClone(obj, hash = new WeakMap()) {
  // 基本类型直接返回
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 特殊对象处理
  const Constructor = obj.constructor;
  
  switch (Constructor) {
    case Date:
      return new Date(obj);
    case RegExp:
      return new RegExp(obj);
    case Map:
      return new Map(Array.from(obj, ([k, v]) => [k, optimizedDeepClone(v, hash)]));
    case Set:
      return new Set(Array.from(obj, v => optimizedDeepClone(v, hash)));
    case ArrayBuffer:
      return obj.slice();
    case DataView:
      return new DataView(obj.buffer.slice(0), obj.byteOffset, obj.byteLength);
    case Int8Array:
    case Uint8Array:
    case Uint8ClampedArray:
    case Int16Array:
    case Uint16Array:
    case Int32Array:
    case Uint32Array:
    case Float32Array:
    case Float64Array:
      return new Constructor(obj);
  }
  
  // 普通对象和数组
  const clone = new Constructor();
  hash.set(obj, clone);
  
  // 使用Reflect.ownKeys获取所有属性（包括Symbol）
  Reflect.ownKeys(obj).forEach(key => {
    clone[key] = optimizedDeepClone(obj[key], hash);
  });
  
  return clone;
}
```

## 六、应用场景与选择建议

### 1. 何时使用浅拷贝

- 对象只有一层属性（无嵌套对象）
- 不需要修改嵌套属性
- 性能要求高，对象结构简单
- 明确知道嵌套对象不需要独立副本

### 2. 何时使用深拷贝

- 对象有多层嵌套结构
- 需要完全独立的副本，修改不影响原对象
- 处理不可变数据
- 需要序列化/反序列化操作
- 在框架中传递状态（如Redux）

### 3. 方法选择指南

| 场景                     | 推荐方法               | 原因                               |
| ------------------------ | ---------------------- | ---------------------------------- |
| **简单对象浅拷贝**       | 扩展运算符或Object.assign | 简洁高效                           |
| **数组浅拷贝**           | slice、concat或扩展运算符 | 简洁高效                           |
| **简单深拷贝（无特殊对象）** | JSON.parse(JSON.stringify) | 简单易用，性能较好                 |
| **复杂深拷贝**           | Lodash.cloneDeep       | 处理各种特殊情况，性能较好         |
| **现代环境深拷贝**       | structuredClone        | 原生支持，性能最好，支持更多类型   |
| **自定义需求**           | 自定义递归函数         | 完全控制，可针对特定需求优化       |

## 七、总结对比表

| 方法                     | 类型   | 循环引用 | 函数 | Date | RegExp | Map/Set | Symbol | 性能 | 使用复杂度 |
| ------------------------ | ------ | -------- | ---- | ---- | ------ | ------- | ------ | ---- | ---------- |
| **扩展运算符**           | 浅拷贝 | -        | -    | -    | -      | -       | -      | 高   | 低         |
| **Object.assign**        | 浅拷贝 | -        | -    | -    | -      | -       | -      | 高   | 低         |
| **JSON方法**             | 深拷贝 | 不支持   | 忽略 | 转字符串 | 转空对象 | 忽略    | 忽略   | 中   | 低         |
| **自定义递归**           | 深拷贝 | 支持     | 支持 | 支持 | 支持   | 需扩展  | 需扩展  | 中   | 高         |
| **Lodash.cloneDeep**     | 深拷贝 | 支持     | 支持 | 支持 | 支持   | 支持    | 支持   | 中高 | 中         |
| **structuredClone**      | 深拷贝 | 支持     | 不支持 | 支持 | 支持   | 支持    | 支持   | 高   | 低         |

## 八、最佳实践

1. **优先使用原生方法**：现代环境优先使用 `structuredClone`
2. **复杂场景用Lodash**：需要处理各种特殊对象时使用 `_.cloneDeep`
3. **避免JSON方法**：除非明确知道对象不包含函数、Date等特殊类型
4. **浅拷贝要谨慎**：确保理解嵌套对象保持引用关系的后果
5. **处理循环引用**：自定义深拷贝函数时务必处理循环引用情况
6. **考虑性能影响**：大型对象深拷贝可能影响性能，必要时使用不可变数据结构

通过理解深拷贝和浅拷贝的区别及各种实现方法，开发者可以根据具体场景选择最合适的拷贝策略，确保代码的正确性和性能。


# JavaScript 深拷贝实现代码及详细解释

## 完整深拷贝实现代码

```javascript
/**
 * 深拷贝函数
 * @param {any} obj - 需要拷贝的对象
 * @param {WeakMap} [hash = new WeakMap()] - 用于处理循环引用
 * @returns {any} 深拷贝后的对象
 */
function deepClone(obj, hash = new WeakMap()) {
  // 1. 处理基本类型和null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 2. 处理日期对象
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // 3. 处理正则表达式
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 4. 处理数组
  if (Array.isArray(obj)) {
    const cloneArr = [];
    hash.set(obj, cloneArr);
    obj.forEach((item, index) => {
      cloneArr[index] = deepClone(item, hash);
    });
    return cloneArr;
  }
  
  // 5. 处理Map对象
  if (obj instanceof Map) {
    const cloneMap = new Map();
    hash.set(obj, cloneMap);
    obj.forEach((value, key) => {
      cloneMap.set(deepClone(key, hash), deepClone(value, hash));
    });
    return cloneMap;
  }
  
  // 6. 处理Set对象
  if (obj instanceof Set) {
    const cloneSet = new Set();
    hash.set(obj, cloneSet);
    obj.forEach(value => {
      cloneSet.add(deepClone(value, hash));
    });
    return cloneSet;
  }
  
  // 7. 处理Buffer对象 (Node.js环境)
  if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
    return Buffer.from(obj);
  }
  
  // 8. 处理ArrayBuffer对象
  if (obj instanceof ArrayBuffer) {
    return obj.slice(0);
  }
  
  // 9. 处理DataView对象
  if (obj instanceof DataView) {
    return new DataView(obj.buffer.slice(0), obj.byteOffset, obj.byteLength);
  }
  
  // 10. 处理TypedArray对象
  if (ArrayBuffer.isView(obj)) {
    return obj.slice();
  }
  
  // 11. 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 12. 处理普通对象
  const cloneObj = Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, cloneObj);
  
  // 获取所有属性（包括Symbol和不可枚举属性）
  const allKeys = Reflect.ownKeys(obj);
  
  for (const key of allKeys) {
    // 跳过不可配置的属性（如length等）
    const descriptor = Object.getOwnPropertyDescriptor(obj, key);
    if (descriptor && !descriptor.configurable) {
      continue;
    }
    
    cloneObj[key] = deepClone(obj[key], hash);
  }
  
  return cloneObj;
}
```

## 逐行详细解释

### 1. 函数定义和参数
```javascript
function deepClone(obj, hash = new WeakMap()) {
```
- 定义 `deepClone` 函数，接收两个参数：
  - `obj`: 需要拷贝的对象
  - `hash`: 用于处理循环引用的 WeakMap，默认为新的 WeakMap 实例

### 2. 处理基本类型和 null
```javascript
if (obj === null || typeof obj !== 'object') {
  return obj;
}
```
- 检查是否为基本类型（string、number、boolean、undefined、symbol）或 null
- 这些类型直接返回值本身，因为它们是不可变的或不需要深拷贝

### 3. 处理日期对象
```javascript
if (obj instanceof Date) {
  return new Date(obj.getTime());
}
```
- 检查是否为 Date 对象
- 通过时间戳创建新的 Date 对象，确保完全独立

### 4. 处理正则表达式
```javascript
if (obj instanceof RegExp) {
  return new RegExp(obj);
}
```
- 检查是否为 RegExp 对象
- 使用 RegExp 构造函数创建新的正则表达式，复制模式和标志

### 5. 处理数组
```javascript
if (Array.isArray(obj)) {
  const cloneArr = [];
  hash.set(obj, cloneArr);
  obj.forEach((item, index) => {
    cloneArr[index] = deepClone(item, hash);
  });
  return cloneArr;
}
```
- 检查是否为数组
- 创建新数组，并在 hash 中记录映射关系
- 遍历原数组，递归深拷贝每个元素
- 返回新数组

### 6. 处理 Map 对象
```javascript
if (obj instanceof Map) {
  const cloneMap = new Map();
  hash.set(obj, cloneMap);
  obj.forEach((value, key) => {
    cloneMap.set(deepClone(key, hash), deepClone(value, hash));
  });
  return cloneMap;
}
```
- 检查是否为 Map 对象
- 创建新 Map，并在 hash 中记录映射关系
- 遍历原 Map，递归深拷贝每个键和值
- 返回新 Map

### 7. 处理 Set 对象
```javascript
if (obj instanceof Set) {
  const cloneSet = new Set();
  hash.set(obj, cloneSet);
  obj.forEach(value => {
    cloneSet.add(deepClone(value, hash));
  });
  return cloneSet;
}
```
- 检查是否为 Set 对象
- 创建新 Set，并在 hash 中记录映射关系
- 遍历原 Set，递归深拷贝每个值
- 返回新 Set

### 8. 处理 Buffer 对象 (Node.js 环境)
```javascript
if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
  return Buffer.from(obj);
}
```
- 检查 Buffer 是否存在（避免浏览器环境报错）
- 检查是否为 Buffer 对象
- 使用 Buffer.from() 创建新 Buffer

### 9. 处理 ArrayBuffer 对象
```javascript
if (obj instanceof ArrayBuffer) {
  return obj.slice(0);
}
```
- 检查是否为 ArrayBuffer 对象
- 使用 slice() 方法创建副本

### 10. 处理 DataView 对象
```javascript
if (obj instanceof DataView) {
  return new DataView(obj.buffer.slice(0), obj.byteOffset, obj.byteLength);
}
```
- 检查是否为 DataView 对象
- 基于复制的 ArrayBuffer 创建新 DataView

### 11. 处理 TypedArray 对象
```javascript
if (ArrayBuffer.isView(obj)) {
  return obj.slice();
}
```
- 检查是否为 TypedArray 对象（Int8Array、Uint8Array 等）
- 使用 slice() 方法创建副本

### 12. 处理循环引用
```javascript
if (hash.has(obj)) {
  return hash.get(obj);
}
```
- 检查是否已处理过该对象（循环引用检测）
- 如果已处理，直接返回之前创建的拷贝

### 13. 处理普通对象
```javascript
const cloneObj = Object.create(Object.getPrototypeOf(obj));
hash.set(obj, cloneObj);
```
- 创建保持原型链的新对象
- 在 hash 中记录映射关系

### 14. 获取并处理所有属性
```javascript
const allKeys = Reflect.ownKeys(obj);

for (const key of allKeys) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, key);
  if (descriptor && !descriptor.configurable) {
    continue;
  }
  
  cloneObj[key] = deepClone(obj[key], hash);
}
```
- 使用 Reflect.ownKeys() 获取所有属性键（包括 Symbol 和不可枚举属性）
- 遍历所有属性，跳过不可配置的属性（如数组的 length）
- 递归深拷贝每个属性值

### 15. 返回最终结果
```javascript
return cloneObj;
```
- 返回深拷贝后的对象

## 使用示例

```javascript
// 创建复杂对象
const original = {
  number: 1,
  string: "hello",
  array: [1, 2, { nested: "value" }],
  object: { 
    nested: { 
      deep: "value",
      date: new Date(),
      regex: /test/g
    }
  },
  map: new Map([["key", "value"]]),
  set: new Set([1, 2, 3]),
  symbol: Symbol("test"),
  function: function() { return "test"; },
  // 循环引用
  circular: null
};

// 创建循环引用
original.circular = original;
original.object.circularRef = original;

// 执行深拷贝
const cloned = deepClone(original);

// 测试修改深拷贝对象是否影响原对象
cloned.object.nested.deep = "modified";
cloned.array[2].nested = "modified";
cloned.map.set("key", "modified");

console.log(original.object.nested.deep); // "value" (未改变)
console.log(original.array[2].nested); // "value" (未改变)
console.log(original.map.get("key")); // "value" (未改变)

// 测试循环引用
console.log(cloned.circular === cloned); // true (循环引用被正确处理)
console.log(cloned.object.circularRef === cloned); // true (循环引用被正确处理)

// 测试特殊对象
console.log(cloned.object.nested.date instanceof Date); // true
console.log(cloned.object.nested.date !== original.object.nested.date); // true
console.log(cloned.object.nested.regex instanceof RegExp); // true
```

## 关键特性

1. **全面类型支持**：处理所有 JavaScript 内置数据类型
2. **循环引用处理**：使用 WeakMap 检测和解决循环引用问题
3. **原型链保持**：使用 Object.create() 保持正确的原型链
4. **完整属性复制**：使用 Reflect.ownKeys() 复制所有属性（包括 Symbol 和不可枚举属性）
5. **递归策略**：深度优先遍历对象结构，确保所有嵌套对象都被正确拷贝

## 注意事项

1. **函数处理**：函数保持引用（不创建副本），因为函数通常不需要复制
2. **DOM元素**：此实现不处理 DOM 元素，需要额外处理
3. **Error对象**：Error 对象需要特殊处理（此实现未包含）
4. **性能考虑**：对于非常大的对象，深拷贝可能影响性能
5. **不可克隆对象**：某些特殊对象（如 Promise、WeakMap、WeakSet）无法完全克隆





# JavaScript 深拷贝中的循环引用与 WeakMap

## 循环引用问题

**循环引用**是指对象之间相互引用形成闭环的情况：

```
const objA = { name: 'A' };
const objB = { name: 'B' };
objA.child = objB;  // A 引用 B
objB.parent = objA; // B 引用 A → 形成循环引用
```

**问题**：深拷贝时如果不处理循环引用，会陷入无限递归，导致栈溢出错误。

## WeakMap 的解决方案

WeakMap 专门用于解决循环引用问题，其核心作用是：**记录已处理对象与其拷贝的映射关系**。

```
function deepClone(obj, hash = new WeakMap()) {
  // 如果已处理过该对象，直接返回其拷贝
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 创建新对象并记录映射关系
  const clone = { /* 新对象 */ };
  hash.set(obj, clone);
  
  // 递归拷贝属性...
  
  return clone;
}
```

## 为什么使用 WeakMap？

1. **弱引用特性**：
   - WeakMap 的键是弱引用，不会阻止垃圾回收
   - 当原始对象不再被使用时，会自动从 WeakMap 中清除
   - 避免内存泄漏问题
2. **专为对象设计**：
   - WeakMap 只接受对象作为键，完美适合对象拷贝场景
   - 相比普通 Map，更轻量且针对对象优化
3. **正确重建引用关系**：
   - 确保循环引用被正确重建，而不是创建无限嵌套的对象
   - 保持对象网络的完整性

## 简单来说

使用 WeakMap 就像在拷贝过程中**记笔记**：

- "这个对象我已经拷贝过了，它的拷贝是那个对象"
- 当再次遇到同一个对象时，直接返回笔记中记录的拷贝
- 这样既避免了无限循环，又正确重建了引用关系

WeakMap 是解决深拷贝中循环引用问题的最优雅和高效的方案。