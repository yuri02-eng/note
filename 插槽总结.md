# Vue插槽(Slot)总结

## 1. 插槽基础

### 1.1 什么是插槽

插槽(Slot)是Vue提供的一种内容分发API，允许开发者在组件模板中预留位置，然后在使用组件时将内容"插入"到这些位置。插槽使得组件更加灵活和可复用。

**插槽**的作用：子组件提供插槽出口（可能会提供数据如具名插槽），父组件提供如何进行渲染

### 1.2 插槽的基本用法

在组件模板中使用`<slot>`标签来定义插槽：

```vue
<!-- 子组件 MyComponent.vue -->
<template>
  <div class="my-component">
    <h2>我是组件标题</h2>
    <slot></slot> <!-- 插槽出口 -->
  </div>
</template>
```

在父组件中使用该组件时，可以在组件标签内放置内容，这些内容将被插入到子组件的`<slot>`位置：

```vue
<!-- 父组件 -->
<template>
  <div>
    <my-component>
      <p>这是插入到插槽的内容</p>
    </my-component>
  </div>
</template>
```

渲染结果：

```html
<div>
  <div class="my-component">
    <h2>我是组件标题</h2>
    <p>这是插入到插槽的内容</p>
  </div>
</div>
```

### 1.3 插槽的默认内容

插槽可以设置默认内容，当父组件没有提供内容时会显示默认内容：

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot>这是默认内容，当没有传入内容时显示</slot>
  </div>
</template>
```

## 2. 具名插槽

### 2.1 什么是具名插槽

当一个组件需要多个插槽时，可以使用具名插槽来区分不同的插槽位置。

### 2.2 具名插槽的定义

在子组件中，通过`name`属性给插槽命名：

```vue
<!-- 子组件 -->
<template>
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot> <!-- 默认插槽，也可以写成 <slot name="default"></slot> -->
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

### 2.3 具名插槽的使用

在Vue 2.6.0之前，使用`slot`属性指定插槽名称：

```vue
<!-- 父组件 (Vue 2.6.0之前) -->
<template>
  <my-component>
    <h1 slot="header">页面标题</h1>
    <p>主要内容</p>
    <p slot="footer">页脚内容</p>
  </my-component>
</template>
```

在Vue 2.6.0之后，使用`v-slot`指令（简写为`#`）：

```vue
<!-- 父组件 (Vue 2.6.0之后) -->
<template>
  <my-component>
    <template v-slot:header>
      <h1>页面标题</h1>
    </template>

    <template v-slot:default>
      <p>主要内容</p>
    </template>

    <template #footer>
      <p>页脚内容</p>
    </template>
  </my-component>
</template>
```

## 3. 作用域插槽

### 3.1 什么是作用域插槽

作用域插槽是一种特殊类型的插槽，它允许子组件将数据传递给父组件，让父组件决定如何渲染子组件的部分内容。

### 3.2 作用域插槽的基本用法

在子组件中，通过`v-bind`将数据传递给插槽：

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot :user="user" :message="message"></slot>
  </div>
</template>

<script>
export default {
  data() {
    return {
      user: { name: '张三', age: 25 },
      message: 'Hello World'
    }
  }
}
</script>
```

在父组件中，通过插槽prop接收子组件传递的数据：

```vue
<!-- 父组件 (Vue 2.6.0之前) -->
<template>
  <my-component>
    <template slot-scope="slotProps">
      <p>用户名: {{ slotProps.user.name }}</p>
      <p>消息: {{ slotProps.message }}</p>
    </template>
  </my-component>
</template>
<!-- 父组件 (Vue 2.6.0之后) -->
<template>
  <my-component>
    <template v-slot:default="slotProps">
      <p>用户名: {{ slotProps.user.name }}</p>
      <p>消息: {{ slotProps.message }}</p>
    </template>
  </my-component>
</template>
```

### 3.3 解构插槽Prop

可以使用ES6解构语法简化代码：

```vue
<template>
  <my-component>
    <template v-slot:default="{ user, message }">
      <p>用户名: {{ user.name }}</p>
      <p>消息: {{ message }}</p>
    </template>
  </my-component>
</template>
```

### 3.4 具名作用域插槽

具名插槽和作用域插槽可以结合使用：

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot name="header" :title="title"></slot>
    <slot name="content" :items="items"></slot>
  </div>
</template>

<script>
export default {
  data() {
    return {
      title: '商品列表',
      items: ['苹果', '香蕉', '橙子']
    }
  }
}
</script>
<!-- 父组件 -->
<template>
  <my-component>
    <template #header="{ title }">
      <h1>{{ title }}</h1>
    </template>

    <template #content="{ items }">
      <ul>
        <li v-for="(item, index) in items" :key="index">{{ item }}</li>
      </ul>
    </template>
  </my-component>
</template>
```

## 4. 动态插槽名

Vue 2.6.0之后，插槽名可以是动态的：

```vue
<template>
  <my-component>
    <template v-slot:[dynamicSlotName]>
      动态插槽内容
    </template>
  </my-component>
</template>

<script>
export default {
  data() {
    return {
      dynamicSlotName: 'header' // 可以动态改变
    }
  }
}
</script>
```

## 5. 插槽的底层原理

### 5.1 编译过程

Vue中的插槽在编译阶段会被转换为特定的渲染函数。以下是插槽编译的基本流程：

1. **模板解析**：Vue将模板解析为AST（抽象语法树）
2. **插槽标记**：识别模板中的`<slot>`标签和组件中的插槽内容
3. **转换**：将插槽内容转换为渲染函数

### 5.2 普通插槽的实现原理

普通插槽（非作用域插槽）在Vue 2中的实现原理：

1. 子组件模板中的`<slot>`标签会被编译为`this.$slots.default`或`this.$slots[name]`
2. 父组件中的插槽内容会被编译并保存在父组件的`$slots`对象中
3. 当子组件渲染时，会使用父组件传入的插槽内容替换子组件模板中的`<slot>`标签

简化的编译后代码示例：

```js
// 子组件渲染函数
render(h) {
  return h('div', [
    h('h2', ['我是组件标题']),
    this.$slots.default // 插入父组件传入的内容
  ])
}

// 父组件渲染函数
render(h) {
  return h('div', [
    h('my-component', {
      // 插槽内容会被保存在$slots中
      scopedSlots: this.$scopedSlots,
      slots: () => [h('p', ['这是插入到插槽的内容'])]
    })
  ])
}
```

### 5.3 作用域插槽的实现原理

作用域插槽在Vue 2中的实现原理：

1. 子组件中的作用域插槽会被编译为`this.$scopedSlots.default(this.data)`或`this.$scopedSlots[name](this.data)`
2. 父组件中的作用域插槽内容会被编译为一个函数，并保存在父组件的`$scopedSlots`对象中
3. 当子组件渲染时，会调用这个函数并传入数据，函数返回的VNode会替换子组件模板中的`<slot>`标签

简化的编译后代码示例：

```js
// 子组件渲染函数
render(h) {
  return h('div', [
    // 调用作用域插槽函数，传入数据
    this.$scopedSlots.default({ user: this.user, message: this.message })
  ])
}

// 父组件渲染函数
render(h) {
  return h('div', [
    h('my-component', {
      // 作用域插槽被编译为函数
      scopedSlots: {
        default: (slotProps) => [
          h('p', ['用户名: ' + slotProps.user.name]),
          h('p', ['消息: ' + slotProps.message])
        ]
      }
    })
  ])
}
```

### 5.4 Vue 3中的插槽实现变化

Vue 3中对插槽实现进行了全面重构，带来了更高的性能和更好的开发体验。以下是五大关键改进：

#### 5.4.1 统一的插槽模型

Vue 3统一了普通插槽和作用域插槽的内部实现，简化了底层代码：

- **Vue 2**：区分`$slots`（普通插槽）和`$scopedSlots`（作用域插槽）
- **Vue 3**：统一为`$slots`，所有插槽都是函数形式

```js
// Vue 2中的插槽访问
this.$slots.default       // 普通插槽：VNode数组
this.$scopedSlots.default // 作用域插槽：返回VNode数组的函数

// Vue 3中的统一访问
this.$slots.default       // 所有插槽都是函数：(props) => VNode数组
```

这种统一简化了组件开发，减少了理解成本，也使得内部实现更加一致。

#### 5.4.2 函数化实现

Vue 3中所有插槽都被编译为函数，保存在组件实例的`slots`对象中：

```js
// Vue 3中的插槽实现（简化）
const instance = {
  slots: {  
    default: (props) => [/* 渲染内容 */],
    header: (props) => [/* 渲染内容 */],
    footer: (props) => [/* 渲染内容 */]
  }
}

// 调用插槽函数
const defaultContent = instance.slots.default(props)
```

函数化实现带来的好处：

1. **一致性**：所有插槽处理逻辑一致
2. **灵活性**：可以传递任意参数给插槽函数
3. **延迟执行**：只有在调用函数时才会创建VNode
4. **更好的类型支持**：TypeScript可以更好地推断插槽props类型

#### 5.4.3 懒执行优化

Vue 3使用Proxy进行了性能优化，只有在实际访问插槽时才会执行相应的渲染函数：

```js
// 内部实现（简化）
const slots = new Proxy(rawSlots, {
  get(target, key) {
    // 只有在访问特定插槽时才会触发渲染
    trackSlotAccess(key)
    return target[key]
  }
})
```

懒执行带来的性能提升：

1. **按需渲染**：未使用的插槽不会被执行
2. **条件渲染优化**：`v-if`条件下的插槽只在条件为真时执行
3. **减少初始渲染成本**：大型组件库中常见的多插槽组件受益明显

#### 5.4.4 更高效的更新机制

Vue 3中插槽内容的更新不再触发父组件的重新渲染，只会影响使用该插槽的子组件：

- **Vue 2**：插槽内容更新会触发父组件重新渲染，然后传递给子组件
- **Vue 3**：插槽内容更新只会触发相关子组件的更新，父组件不受影响

这种机制通过以下方式实现：

1. **插槽内容编译时标记**：编译器会为动态插槽内容添加特殊标记
2. **精确依赖追踪**：运行时系统精确追踪插槽内容的依赖关系
3. **组件边界优化**：更新时只穿透必要的组件边界

```js
// Vue 3中的更新机制（简化）
function updateComponent() {
  // 只更新真正需要更新的部分
  if (shouldUpdateSlots) {
    updateComponentSlots(instance, nextVNode.children)
  }
}
```

#### 5.4.5 Fragment支持

Vue 3支持Fragment（片段），使得插槽内容可以包含多个根节点：

```vue
<!-- Vue 2中插槽内容必须有一个根元素 -->
<template v-slot:header>
  <div>
    <h1>标题</h1>
    <p>副标题</p>
  </div>
</template>

<!-- Vue 3中插槽内容可以有多个根节点 -->
<template #header>
  <h1>标题</h1>
  <p>副标题</p>
</template>
```

Fragment支持的好处：

1. **减少不必要的包装元素**：避免额外的DOM节点
2. **更符合语义化**：可以直接使用语义化标签而不需要包装
3. **更灵活的布局**：特别是在表格、列表等严格结构中更有用
4. **更好的性能**：减少DOM节点数量，降低内存占用和渲染成本

### 5.5 Vue 3插槽编译优化

Vue 3在编译阶段对插槽进行了多项优化，这些优化大幅提升了插槽的性能和渲染效率。

#### 5.5.1 Block Tree优化

Vue 3引入了Block Tree概念，可以更精确地跟踪动态节点，减少不必要的更新：

```js
// Vue 3中的Block Tree（简化）
const block = {
  type: Fragment,
  dynamicChildren: [ /* 只包含动态节点的平面数组 */ ],
  el: null,
  anchor: null
}
```

**Block Tree如何优化插槽：**

1. **扁平化动态节点追踪**：不再需要递归遍历整个组件树
2. **精确更新**：只更新真正变化的节点，而不是整个插槽内容
3. **稳定的节点引用**：动态节点的引用在更新过程中保持稳定

在插槽渲染中，Block Tree使得插槽内容的更新更加高效：

```js
// 编译后的插槽渲染（简化）
function renderSlot(slots, name, props) {
  // 创建一个Block，包含所有动态节点
  return openBlock(), createBlock(Fragment, { key: props.key }, 
    slots[name](props), 
    PatchFlags.STABLE_FRAGMENT
  )
}
```

#### 5.5.2 静态提升

静态的插槽内容会被提升到渲染函数之外，避免在每次渲染时重复创建：

```js
// 静态内容提升到渲染函数外部
const _hoisted_1 = /*#__PURE__*/_createElementVNode("div", { class: "static-content" }, [
  /*#__PURE__*/_createElementVNode("span", null, "静态标题"),
  /*#__PURE__*/_createElementVNode("p", null, "静态描述")
], -1 /* HOISTED */)

// 渲染函数
return function render() {
  return (_openBlock(), _createBlock("div", null, [
    _hoisted_1, // 直接使用提升的静态内容
    _renderSlot(_ctx.$slots, "default", { item: _ctx.item })
  ]))
}
```

**静态提升的优势：**

1. **减少内存分配**：静态内容只创建一次，而不是每次渲染都创建
2. **减少GC压力**：减少临时对象的创建和销毁
3. **提高渲染速度**：跳过静态内容的比对和更新

#### 5.5.3 PatchFlag标记

编译器会为插槽内容添加PatchFlag，指示运行时如何高效地更新内容：

```js
// 带有PatchFlag的动态内容
const _createVNode = _createElementVNode("div", { class: "dynamic-content" }, 
  _ctx.message, // 动态文本内容
  1 /* TEXT */ // PatchFlag: 只需要更新文本内容
)

// 插槽渲染
_renderSlot(_ctx.$slots, "default", 
  { item: _ctx.item }, // 插槽props
  undefined,
  true // 是否稳定，用于优化更新
)
```

**PatchFlag类型及其在插槽中的应用：**

| PatchFlag        | 值    | 描述          | 插槽应用           |
| ---------------- | ---- | ----------- | -------------- |
| TEXT             | 1    | 动态文本内容      | 插槽内的文本绑定       |
| CLASS            | 2    | 动态class     | 插槽内的样式绑定       |
| STYLE            | 4    | 动态style     | 插槽内的内联样式       |
| PROPS            | 8    | 动态属性        | 插槽内的属性绑定       |
| FULL_PROPS       | 16   | 需要完整diff的属性 | 复杂插槽内容         |
| HYDRATE_EVENTS   | 32   | 需要事件监听器     | 插槽内的事件处理       |
| STABLE_FRAGMENT  | 64   | 子节点顺序不变的片段  | 大多数插槽内容        |
| KEYED_FRAGMENT   | 128  | 带key的子节点    | v-for中的插槽      |
| UNKEYED_FRAGMENT | 256  | 无key的子节点    | 简单列表插槽         |
| NEED_PATCH       | 512  | 需要通过组件修补    | 组件插槽           |
| DYNAMIC_SLOTS    | 1024 | 动态插槽        | v-if/v-for中的插槽 |

#### 5.5.4 编译时插槽优化示例

以下是一个完整的编译优化示例，展示了Vue 3如何优化插槽内容的编译：

```js
// 原始模板
// <div>
//   <my-component>
//     <template #header>
//       <h1>{{ title }}</h1>
//     </template>
//     <template #default="{ item }">
//       <div>{{ item.name }}</div>
//     </template>
//   </my-component>
// </div>

// 编译后的渲染函数（简化）
import { openBlock, createBlock, createVNode, renderSlot, toDisplayString } from 'vue'

// 静态节点提升
const _hoisted_1 = { class: "header-wrapper" }

export function render(_ctx, _cache) {
  return (openBlock(), createBlock("div", null, [
    createVNode(_component_my_component, null, {
      // 具名插槽 - 带有动态内容
      header: withCtx(() => [
        createVNode("h1", _hoisted_1, toDisplayString(_ctx.title), 1 /* TEXT */)
      ]),
      // 作用域插槽 - 使用从子组件接收的数据
      default: withCtx(({ item }) => [
        createVNode("div", null, toDisplayString(item.name), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    })
  ]))
}
```

这个编译后的代码展示了：

1. 静态属性（`class="header-wrapper"`）被提升
2. 动态内容（`{{ title }}`和`{{ item.name }}`）被标记为TEXT类型的PatchFlag
3. 插槽函数使用`withCtx`包装，确保正确的渲染上下文
4. `_: 1`表示这是稳定的插槽，不需要在每次更新时重新创建

### 5.6 Vue 3 Composition API中的插槽

Vue 3的Composition API提供了新的方式来访问和使用插槽，使得插槽操作更加灵活和直观。

#### 5.6.1 使用useSlots和useAttrs访问插槽

在Composition API中，可以使用`useSlots()`和`useAttrs()`来访问插槽和属性：

```js
// 在setup函数中访问插槽
import { useSlots, useAttrs } from 'vue'

export default {
  setup() {
    // 获取所有插槽
    const slots = useSlots()
    // 获取所有非prop属性
    const attrs = useAttrs()

    // 检查插槽是否存在
    const hasDefaultSlot = !!slots.default
    const hasHeaderSlot = !!slots.header

    // 调用插槽函数获取VNode
    const defaultContent = slots.default ? slots.default({ item: 'data' }) : null

    return {
      hasDefaultSlot,
      hasHeaderSlot
    }
  }
}
```

#### 5.6.2 在`<script setup>`中使用插槽

在`<script setup>`语法中，可以更简洁地使用插槽：

```vue
<script setup>
import { useSlots, computed } from 'vue'

// 获取插槽
const slots = useSlots()

// 使用计算属性检查插槽是否存在
const hasHeaderSlot = computed(() => !!slots.header)
const hasFooterSlot = computed(() => !!slots.footer)

// 根据插槽存在与否动态调整组件行为
const showDefaultHeader = computed(() => !hasHeaderSlot.value && props.title)

// 可以在生命周期钩子或其他函数中使用插槽
onMounted(() => {
  if (slots.default) {
    console.log('默认插槽已提供')
  }
})
</script>

<template>
  <div class="card">
    <div v-if="hasHeaderSlot" class="card-header">
      <slot name="header"></slot>
    </div>
    <div v-else-if="showDefaultHeader" class="card-header">
      <h3>{{ title }}</h3>
    </div>

    <div class="card-body">
      <slot></slot>
    </div>

    <div v-if="hasFooterSlot" class="card-footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>
```

#### 5.6.3 动态渲染插槽内容

Composition API使得动态渲染插槽内容变得更加灵活：

```vue
<script setup>
import { useSlots, h, ref } from 'vue'

const slots = useSlots()
const currentTab = ref('info')

// 动态渲染不同的插槽内容
function renderTabContent() {
  const slotName = `tab-${currentTab.value}`

  if (slots[slotName]) {
    return slots[slotName]()
  } else if (slots.default) {
    return slots.default({ tab: currentTab.value })
  } else {
    return h('div', { class: 'empty-tab' }, '没有内容')
  }
}
</script>

<template>
  <div class="tabs-container">
    <div class="tabs-header">
      <button 
        v-for="tab in ['info', 'details', 'settings']"
        :key="tab"
        :class="{ active: currentTab === tab }"
        @click="currentTab = tab"
      >
        {{ tab }}
      </button>
    </div>

    <div class="tab-content">
      <component :is="renderTabContent" />
    </div>
  </div>
</template>
```

#### 5.6.4 插槽内容的响应式处理

Composition API中可以结合响应式系统处理插槽内容：

```vue
<script setup>
import { useSlots, watch, ref, onMounted } from 'vue'

const slots = useSlots()
const slotContent = ref(null)
const hasCustomContent = ref(false)

// 监听插槽变化
watch(() => slots.default, (newSlot) => {
  hasCustomContent.value = !!newSlot
  if (newSlot) {
    // 处理新的插槽内容
    processSlotContent(newSlot)
  }
}, { immediate: true })

// 处理插槽内容
function processSlotContent(slot) {
  // 可以在这里对插槽内容进行分析或处理
  const renderedContent = slot()
  slotContent.value = renderedContent

  // 例如：统计插槽内的元素数量
  console.log(`插槽内包含 ${renderedContent.length} 个顶级元素`)
}

onMounted(() => {
  // 在挂载后处理插槽内容
  if (slots.default) {
    processSlotContent(slots.default)
  }
})
</script>
```

#### 5.6.5 插槽与provide/inject结合

Composition API中可以结合`provide`和`inject`来增强插槽功能：

```vue
<!-- 父组件 -->
<script setup>
import { provide, ref } from 'vue'

// 提供上下文数据，可以被插槽内容访问
const theme = ref('light')
const toggleTheme = () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
}

provide('theme', theme)
provide('toggleTheme', toggleTheme)
</script>

<template>
  <layout-component>
    <template #header>
      <app-header />
    </template>

    <template #sidebar>
      <!-- 插槽内容可以通过inject访问provide的数据 -->
      <sidebar-component />
    </template>

    <template #default>
      <main-content />
    </template>
  </layout-component>
</template>

<!-- 子组件 SidebarComponent.vue -->
<script setup>
import { inject } from 'vue'

// 在插槽内容中注入父组件提供的数据
const theme = inject('theme')
const toggleTheme = inject('toggleTheme')
</script>

<template>
  <div :class="['sidebar', theme]">
    <button @click="toggleTheme">切换主题</button>
    <!-- 侧边栏内容 -->
  </div>
</template>
```

#### 5.6.6 在渲染函数中使用插槽

Composition API与渲染函数结合使用插槽：

```js
import { defineComponent, h, useSlots } from 'vue'

export default defineComponent({
  props: ['level'],
  setup(props) {
    const slots = useSlots()

    return () => {
      // 动态创建标题元素
      const tag = `h${props.level || 1}`

      // 渲染默认插槽内容
      const defaultSlotContent = slots.default ? slots.default() : []

      // 渲染前缀插槽内容
      const prefixContent = slots.prefix ? slots.prefix() : []

      // 渲染后缀插槽内容
      const suffixContent = slots.suffix ? slots.suffix() : []

      // 组合所有内容
      return h(tag, [
        ...prefixContent,
        ...defaultSlotContent,
        ...suffixContent
      ])
    }
  }
})
```

使用示例：

```vue
<template>
  <dynamic-heading :level="2">
    <template #prefix>
      <icon-star />
    </template>

    主标题内容

    <template #suffix>
      <badge type="new" />
    </template>
  </dynamic-heading>
</template>
```

## 6. 插槽最佳实践

### 6.1 何时使用不同类型的插槽

- **默认插槽**：当组件只需要一个插槽位置时使用
- **具名插槽**：当组件需要多个不同位置的插槽时使用
- **作用域插槽**：当子组件需要向父组件传递数据，让父组件决定如何渲染时使用

### 6.2 插槽性能优化

1. **避免过度使用作用域插槽**：作用域插槽会增加渲染成本，只在必要时使用
2. **合理设置插槽默认内容**：为插槽提供合理的默认内容，提高组件的易用性
3. **使用v-once优化静态内容**：对于不会改变的插槽内容，可以使用`v-once`指令优化性能

### 6.3 常见插槽使用场景

1. **布局组件**：如页面布局、卡片、面板等
2. **列表渲染**：自定义列表项的渲染方式
3. **表格组件**：自定义表格单元格的渲染
4. **表单组件**：自定义表单项的渲染

## 7. Vue 2与Vue 3插槽语法对比

### 7.1 Vue 2插槽语法

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot name="header"></slot>
    <slot :item="item"></slot>
  </div>
</template>

<!-- 父组件 -->
<template>
  <my-component>
    <template slot="header">
      <h1>标题</h1>
    </template>

    <template slot-scope="{ item }">
      <p>{{ item.name }}</p>
    </template>
  </my-component>
</template>
```

### 7.2 Vue 2.6+插槽语法

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot name="header"></slot>
    <slot :item="item"></slot>
  </div>
</template>

<!-- 父组件 -->
<template>
  <my-component>
    <template v-slot:header>
      <h1>标题</h1>
    </template>

    <template v-slot:default="{ item }">
      <p>{{ item.name }}</p>
    </template>
  </my-component>
</template>
```

### 7.3 Vue 3插槽语法

Vue 3沿用了Vue 2.6+的`v-slot`语法，但在内部实现上进行了优化，并且在Composition API中提供了新的使用方式：

#### 7.3.1 模板语法（与Vue 2.6+相同）

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot name="header"></slot>
    <slot :item="item"></slot>
  </div>
</template>

<!-- 父组件 -->
<template>
  <my-component>
    <template #header>
      <h1>标题</h1>
    </template>

    <template #default="{ item }">
      <p>{{ item.name }}</p>
    </template>
  </my-component>
</template>
```

#### 7.3.2 Composition API中的插槽使用

在Vue 3的Composition API中，可以使用`useSlots()`和`useAttrs()`来访问插槽和属性：

```vue
<!-- 子组件 MyComponent.vue -->
<script setup>
import { useSlots, computed } from 'vue'

// 定义props
const props = defineProps({
  title: String
})

// 获取插槽
const slots = useSlots()

// 检查插槽是否存在
const hasHeaderSlot = computed(() => !!slots.header)
const hasDefaultSlot = computed(() => !!slots.default)

// 可以根据插槽是否存在来调整组件行为
const showDefaultHeader = computed(() => !hasHeaderSlot.value && props.title)
</script>

<template>
  <div class="my-component">
    <!-- 根据插槽存在与否渲染不同内容 -->
    <header v-if="hasHeaderSlot">
      <slot name="header"></slot>
    </header>
    <h2 v-else-if="showDefaultHeader">{{ title }}</h2>

    <div class="content">
      <slot :data="{ name: '张三', items: ['苹果', '香蕉'] }"></slot>
    </div>
  </div>
</template>
```

#### 7.3.3 渲染函数中的插槽使用

Vue 3中，在渲染函数中使用插槽更加直观：

```js
// 使用h函数的渲染函数组件
import { h } from 'vue'

export default {
  props: ['title'],

  render() {
    // 检查插槽是否存在
    const hasDefaultSlot = this.$slots.default !== undefined
    const hasHeaderSlot = this.$slots.header !== undefined

    // 创建header内容
    const header = hasHeaderSlot
      ? this.$slots.header()
      : this.title
        ? h('h2', this.title)
        : null

    // 创建default内容
    const defaultContent = hasDefaultSlot
      ? this.$slots.default({ item: { name: '张三' } })
      : h('div', '没有内容')

    // 返回VNode
    return h('div', { class: 'my-component' }, [
      header,
      h('div', { class: 'content' }, defaultContent)
    ])
  }
}

## 8. Vue 3中的高级插槽用法

### 8.1 插槽与Teleport结合

Vue 3引入的`<Teleport>`组件可以与插槽结合使用，实现更灵活的内容分发。这种组合特别适合创建模态框、弹出菜单等需要在DOM树中不同位置渲染的组件。

```vue
<!-- 子组件 Modal.vue -->
<template>
  <teleport to="body">
    <div class="modal-overlay" v-if="isOpen">
      <div class="modal" :class="modalClass">
        <div class="modal-header">
          <slot name="header" :close="close">默认标题</slot>
          <button @click="close" class="close-btn">×</button>
        </div>
        <div class="modal-body">
          <slot :data="modalData"></slot>
        </div>
        <div class="modal-footer">
          <slot name="footer" :close="close" :confirm="confirm">
            <button @click="close" class="btn btn-secondary">关闭</button>
            <button @click="confirm" class="btn btn-primary">确认</button>
          </slot>
        </div>
      </div>
    </div>
  </teleport>
</template>

<script setup>
import { defineProps, defineEmits, ref, watch } from 'vue'

const props = defineProps({
  isOpen: Boolean,
  modalClass: {
    type: String,
    default: ''
  },
  data: {
    type: Object,
    default: () => ({})
  }
})

const modalData = ref(props.data)

// 监听props.data变化
watch(() => props.data, (newData) => {
  modalData.value = newData
})

const emit = defineEmits(['close', 'confirm'])

function close() {
  emit('close')
}

function confirm() {
  emit('confirm', modalData.value)
}

// 添加ESC键关闭功能
function handleKeydown(e) {
  if (e.key === 'Escape' && props.isOpen) {
    close()
  }
}

onMounted(() => {
  document.addEventListener('keydown', handleKeydown)
})

onUnmounted(() => {
  document.removeEventListener('keydown', handleKeydown)
})
</script>
```

使用示例：

```vue
<template>
  <div>
    <button @click="openModal">打开模态框</button>

    <modal :is-open="isModalOpen" :data="userData" @close="closeModal" @confirm="handleConfirm">
      <template #header="{ close }">
        <div class="custom-header">
          <h2>用户信息</h2>
          <button @click="close" class="custom-close">关闭</button>
        </div>
      </template>

      <template #default="{ data }">
        <form class="user-form">
          <div class="form-group">
            <label>用户名</label>
            <input v-model="data.username" type="text" />
          </div>
          <div class="form-group">
            <label>邮箱</label>
            <input v-model="data.email" type="email" />
          </div>
        </form>
      </template>

      <template #footer="{ close, confirm }">
        <div class="custom-footer">
          <button @click="close" class="btn-cancel">取消</button>
          <button @click="confirm" class="btn-save">保存</button>
        </div>
      </template>
    </modal>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import Modal from './Modal.vue'

const isModalOpen = ref(false)
const userData = ref({
  username: '张三',
  email: 'zhangsan@example.com'
})

function openModal() {
  isModalOpen.value = true
}

function closeModal() {
  isModalOpen.value = false
}

function handleConfirm(data) {
  console.log('保存用户数据:', data)
  closeModal()
}
</script>
```

### 8.2 插槽与Suspense结合

Vue 3的`<Suspense>`组件提供了两个插槽：`default`和`fallback`，用于处理异步组件和异步setup函数。这种组合特别适合处理数据加载状态和错误处理。

```vue
<template>
  <div class="data-container">
    <suspense>
      <template #default>
        <async-data-component :id="dataId" />
      </template>

      <template #fallback>
        <div class="loading-state">
          <spinner-component />
          <p>正在加载数据，请稍候...</p>
        </div>
      </template>
    </suspense>

    <!-- 错误处理 -->
    <div v-if="error" class="error-container">
      <p>加载失败: {{ error.message }}</p>
      <button @click="retry">重试</button>
    </div>
  </div>
</template>

<script setup>
import { ref, shallowRef, onErrorCaptured } from 'vue'
import { defineAsyncComponent } from 'vue'
import SpinnerComponent from './SpinnerComponent.vue'

// 使用defineAsyncComponent定义异步组件
const AsyncDataComponent = defineAsyncComponent({
  loader: () => import('./AsyncDataComponent.vue'),
  delay: 200,  // 延迟显示加载状态的时间
  timeout: 10000,  // 超时时间
  errorComponent: ErrorComponent,  // 加载失败时显示的组件
  loadingComponent: LoadingComponent  // 加载中显示的组件（Suspense的fallback插槽优先级更高）
})

const dataId = ref('data-123')
const error = shallowRef(null)

// 捕获异步组件中的错误
onErrorCaptured((e) => {
  error.value = e
  return false // 阻止错误继续传播
})

function retry() {
  error.value = null
  dataId.value = dataId.value // 触发重新加载
}
</script>
```

异步组件示例（使用async setup）：

```vue
<!-- AsyncDataComponent.vue -->
<template>
  <div class="data-display">
    <h2>{{ data.title }}</h2>
    <div class="content">
      {{ data.content }}
    </div>
    <div class="metadata">
      <span>作者: {{ data.author }}</span>
      <span>发布时间: {{ formatDate(data.publishDate) }}</span>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const props = defineProps({
  id: {
    type: String,
    required: true
  }
})

// 使用async setup，Suspense会等待这个Promise解析
const data = await fetchData(props.id)

async function fetchData(id) {
  // 模拟API调用
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.2) { // 80%成功率
        resolve({
          title: '异步数据标题',
          content: '这是通过异步加载获取的内容...',
          author: '张三',
          publishDate: new Date()
        })
      } else {
        reject(new Error('网络错误，请稍后重试'))
      }
    }, 1500)
  })
}

function formatDate(date) {
  return new Intl.DateTimeFormat('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  }).format(date)
}
</script>
```

### 8.3 插槽与动态组件结合

插槽与动态组件结合使用可以创建高度灵活的界面，如标签页、多视图界面等。

```vue
<template>
  <div class="dynamic-component-container">
    <!-- 组件选择器 -->
    <div class="component-selector">
      <button 
        v-for="comp in availableComponents" 
        :key="comp.name"
        :class="{ active: currentComponent === comp.name }"
        @click="currentComponent = comp.name"
      >
        {{ comp.label }}
      </button>
    </div>

    <!-- 动态组件与插槽结合 -->
    <component 
      :is="resolveComponent(currentComponent)" 
      :config="componentConfig[currentComponent] || {}"
    >
      <!-- 通用头部插槽 -->
      <template #header>
        <div class="common-header">
          <h2>{{ currentComponentLabel }}</h2>
          <div class="actions">
            <slot name="header-actions"></slot>
          </div>
        </div>
      </template>

      <!-- 动态传递作用域插槽数据 -->
      <template #default="slotProps">
        <div class="dynamic-content">
          <!-- 根据当前组件类型渲染不同内容 -->
          <template v-if="currentComponent === 'data-table'">
            <data-table-content :items="slotProps.items" />
          </template>

          <template v-else-if="currentComponent === 'chart'">
            <chart-content :data="slotProps.data" :type="slotProps.type" />
          </template>

          <template v-else>
            <div class="default-content">
              <p>{{ slotProps.message || '默认内容' }}</p>
            </div>
          </template>
        </div>
      </template>

      <!-- 通用底部插槽 -->
      <template #footer="{ onSave, onCancel }">
        <div class="common-footer">
          <button @click="onCancel" class="btn-cancel">取消</button>
          <button @click="onSave" class="btn-save">保存</button>
        </div>
      </template>
    </component>
  </div>
</template>

<script setup>
import { ref, computed, markRaw, shallowRef } from 'vue'
import DataTableComponent from './DataTableComponent.vue'
import ChartComponent from './ChartComponent.vue'
import FormComponent from './FormComponent.vue'
import DataTableContent from './DataTableContent.vue'
import ChartContent from './ChartContent.vue'

// 使用markRaw避免组件被代理，提高性能
const components = {
  'data-table': markRaw(DataTableComponent),
  'chart': markRaw(ChartComponent),
  'form': markRaw(FormComponent)
}

const availableComponents = [
  { name: 'data-table', label: '数据表格' },
  { name: 'chart', label: '图表' },
  { name: 'form', label: '表单' }
]

const currentComponent = ref('data-table')

// 组件配置
const componentConfig = {
  'data-table': {
    columns: [
      { key: 'name', title: '名称' },
      { key: 'value', title: '值' }
    ],
    pagination: true
  },
  'chart': {
    type: 'bar',
    showLegend: true
  },
  'form': {
    fields: ['name', 'email', 'phone'],
    validation: true
  }
}

// 计算当前组件的标签
const currentComponentLabel = computed(() => {
  const comp = availableComponents.find(c => c.name === currentComponent.value)
  return comp ? comp.label : ''
})

// 解析组件
function resolveComponent(name) {
  return components[name] || 'div'
}
</script>
```

### 8.4 递归组件中的插槽

Vue 3中递归组件与插槽结合使用更加简洁，特别适合构建树形结构、嵌套菜单等复杂UI组件。

```vue
<!-- TreeNode.vue -->
<template>
  <div 
    class="tree-node" 
    :class="{ 'is-leaf': isLeaf, 'is-expanded': expanded, 'is-selected': selected }"
  >
    <div 
      class="node-content" 
      @click="handleNodeClick"
    >
      <!-- 展开/折叠图标 -->
      <span 
        v-if="!isLeaf" 
        class="expand-icon"
        @click.stop="toggle"
      >
        {{ expanded ? '▼' : '►' }}
      </span>
      <span v-else class="leaf-icon">●</span>

      <!-- 节点内容插槽 - 作用域插槽传递节点数据和状态 -->
      <slot 
        :node="node" 
        :level="level"
        :is-leaf="isLeaf"
        :is-expanded="expanded"
        :is-selected="selected"
        :toggle="toggle"
        :select="select"
      >
        <span class="node-label">{{ node.label }}</span>
      </slot>

      <!-- 节点操作插槽 -->
      <div class="node-actions" @click.stop>
        <slot 
          name="actions" 
          :node="node"
          :remove="() => $emit('remove', node)"
          :add="() => $emit('add', node)"
          :edit="() => $emit('edit', node)"
        >
          <!-- 默认操作按钮 -->
          <button v-if="!isLeaf" @click="$emit('add', node)" class="action-btn add-btn">+</button>
          <button @click="$emit('edit', node)" class="action-btn edit-btn">✎</button>
          <button @click="$emit('remove', node)" class="action-btn remove-btn">×</button>
        </slot>
      </div>
    </div>

    <!-- 子节点容器 -->
    <transition name="expand">
      <div v-if="expanded && hasChildren" class="children">
        <tree-node 
          v-for="child in node.children" 
          :key="child.id" 
          :node="child" 
          :level="level + 1"
          :selected-keys="selectedKeys"
          @select="(key) => $emit('select', key)"
          @remove="(node) => $emit('remove', node)"
          @add="(node) => $emit('add', node)"
          @edit="(node) => $emit('edit', node)"
        >
          <!-- 将所有插槽传递给子节点 -->
          <template v-for="(_, name) in $slots" #[name]="slotData">
            <slot :name="name" v-bind="slotData"></slot>
          </template>
        </tree-node>
      </div>
    </transition>
  </div>
</template>

<script setup>
import { computed, ref, toRefs } from 'vue'

// 在Vue 3中，递归组件不需要额外的名称注册
const props = defineProps({
  node: {
    type: Object,
    required: true
  },
  level: {
    type: Number,
    default: 0
  },
  selectedKeys: {
    type: Array,
    default: () => []
  }
})

const emit = defineEmits(['select', 'remove', 'add', 'edit'])

const { node, selectedKeys } = toRefs(props)

// 计算属性
const hasChildren = computed(() => 
  node.value.children && node.value.children.length > 0
)

const isLeaf = computed(() => !hasChildren.value)

const selected = computed(() => 
  selectedKeys.value.includes(node.value.id)
)

// 状态
const expanded = ref(false)

// 方法
function toggle() {
  expanded.value = !expanded.value
}

function select() {
  emit('select', node.value.id)
}

function handleNodeClick() {
  select()
  if (!isLeaf.value && !expanded.value) {
    toggle()
  }
}
</script>

<style scoped>
.tree-node {
  padding-left: 16px;
}

.node-content {
  display: flex;
  align-items: center;
  padding: 5px 0;
  cursor: pointer;
}

.expand-icon, .leaf-icon {
  margin-right: 5px;
  width: 16px;
  text-align: center;
}

.node-actions {
  margin-left: auto;
  opacity: 0;
  transition: opacity 0.2s;
}

.node-content:hover .node-actions {
  opacity: 1;
}

.action-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  margin-left: 4px;
}

.is-selected > .node-content {
  background-color: #e6f7ff;
}

/* 展开/折叠动画 */
.expand-enter-active,
.expand-leave-active {
  transition: all 0.3s ease;
  overflow: hidden;
}

.expand-enter-from,
.expand-leave-to {
  height: 0;
  opacity: 0;
}
</style>
```

使用示例：

```vue
<template>
  <div class="tree-container">
    <h2>文件结构</h2>

    <tree-node 
      :node="rootNode" 
      :selected-keys="selectedKeys"
      @select="handleSelect"
      @remove="handleRemove"
      @add="handleAdd"
      @edit="handleEdit"
    >
      <!-- 自定义节点渲染 -->
      <template #default="{ node, isLeaf, isExpanded, level }">
        <div class="custom-node" :style="{ paddingLeft: `${level * 8}px` }">
          <icon :type="isLeaf ? 'file' : (isExpanded ? 'folder-open' : 'folder')" />
          <span class="node-name">{{ node.label }}</span>
          <span v-if="node.meta" class="node-meta">({{ node.meta }})</span>
        </div>
      </template>

      <!-- 自定义操作按钮 -->
      <template #actions="{ node, remove, add, edit }">
        <div class="custom-actions">
          <tooltip content="添加子节点">
            <button @click="add" class="icon-btn"><icon type="plus" /></button>
          </tooltip>
          <tooltip content="编辑节点">
            <button @click="edit" class="icon-btn"><icon type="edit" /></button>
          </tooltip>
          <tooltip content="删除节点">
            <button @click="remove" class="icon-btn"><icon type="delete" /></button>
          </tooltip>
        </div>
      </template>
    </tree-node>

    <!-- 节点编辑对话框 -->
    <node-edit-dialog 
      v-if="editingNode" 
      :node="editingNode"
      :is-new="isNewNode"
      @save="saveNode"
      @cancel="cancelEdit"
    />
  </div>
</template>

<script setup>
import { ref } from 'vue'
import TreeNode from './TreeNode.vue'
import Icon from './Icon.vue'
import Tooltip from './Tooltip.vue'
import NodeEditDialog from './NodeEditDialog.vue'

// 示例数据
const rootNode = ref({
  id: 'root',
  label: '项目根目录',
  children: [
    {
      id: 'src',
      label: 'src',
      children: [
        { id: 'components', label: 'components', children: [] },
        { id: 'assets', label: 'assets', children: [] },
        { id: 'App.vue', label: 'App.vue', meta: 'Vue' },
        { id: 'main.js', label: 'main.js', meta: 'JS' }
      ]
    },
    {
      id: 'public',
      label: 'public',
      children: [
        { id: 'index.html', label: 'index.html', meta: 'HTML' },
        { id: 'favicon.ico', label: 'favicon.ico', meta: 'ICO' }
      ]
    },
    { id: 'package.json', label: 'package.json', meta: 'JSON' }
  ]
})

const selectedKeys = ref([])
const editingNode = ref(null)
const isNewNode = ref(false)
const parentNode = ref(null)

function handleSelect(nodeId) {
  selectedKeys.value = [nodeId]
}

function handleRemove(node) {
  // 实现节点删除逻辑
  if (confirm(`确定要删除 ${node.label} 吗？`)) {
    removeNodeById(rootNode.value, node.id)
  }
}

function handleAdd(node) {
  isNewNode.value = true
  parentNode.value = node
  editingNode.value = { id: '', label: '', meta: '' }
}

function handleEdit(node) {
  isNewNode.value = false
  editingNode.value = { ...node }
}

function saveNode(node) {
  if (isNewNode.value && parentNode.value) {
    // 添加新节点
    const newNode = {
      ...node,
      id: `node-${Date.now()}`, // 生成唯一ID
      children: []
    }
    if (!parentNode.value.children) {
      parentNode.value.children = []
    }
    parentNode.value.children.push(newNode)
  } else {
    // 更新现有节点
    updateNodeById(rootNode.value, node.id, node)
  }
  cancelEdit()
}

function cancelEdit() {
  editingNode.value = null
  parentNode.value = null
  isNewNode.value = false
}

// 辅助函数：根据ID删除节点
function removeNodeById(tree, id) {
  if (!tree.children) return false

  const index = tree.children.findIndex(child => child.id === id)
  if (index !== -1) {
    tree.children.splice(index, 1)
    return true
  }

  return tree.children.some(child => removeNodeById(child, id))
}

// 辅助函数：根据ID更新节点
function updateNodeById(tree, id, newData) {
  if (tree.id === id) {
    Object.assign(tree, newData)
    return true
  }

  if (!tree.children) return false

  return tree.children.some(child => updateNodeById(child, id, newData))
}
</script>
```

### 8.5 插槽与自定义指令结合

Vue 3中的插槽可以与自定义指令结合使用，创建更加灵活的组件：

```vue
<!-- ContextMenu.vue -->
<template>
  <div 
    v-click-outside="close"
    class="context-menu-trigger"
    @contextmenu.prevent="open"
  >
    <!-- 默认插槽 - 触发区域 -->
    <slot></slot>

    <!-- 菜单内容 -->
    <teleport to="body">
      <div 
        v-if="isOpen" 
        class="context-menu"
        :style="menuStyle"
      >
        <!-- 菜单项插槽 -->
        <slot 
          name="menu" 
          :close="close"
          :position="position"
        ></slot>
      </div>
    </teleport>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

// 自定义指令：点击外部关闭
const vClickOutside = {
  mounted(el, binding) {
    el._clickOutside = (event) => {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event)
      }
    }
    document.addEventListener('click', el._clickOutside)
  },
  unmounted(el) {
    document.removeEventListener('click', el._clickOutside)
  }
}

const isOpen = ref(false)
const position = ref({ x: 0, y: 0 })

const menuStyle = computed(() => ({
  position: 'fixed',
  left: `${position.value.x}px`,
  top: `${position.value.y}px`
}))

function open(event) {
  position.value = {
    x: event.clientX,
    y: event.clientY
  }
  isOpen.value = true
  event.stopPropagation()
}

function close() {
  isOpen.value = false
}
</script>

<style scoped>
.context-menu {
  position: fixed;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  padding: 5px 0;
  min-width: 150px;
  z-index: 1000;
}
</style>
```

使用示例：

```vue
<template>
  <div class="editor">
    <h2>文档编辑器</h2>

    <context-menu>
      <!-- 触发区域 -->
      <div class="editor-content" contenteditable="true">
        {{ content }}
      </div>

      <!-- 自定义菜单 -->
      <template #menu="{ close }">
        <div class="menu-item" @click="formatText('bold'); close()">
          <icon type="bold" /> 加粗
        </div>
        <div class="menu-item" @click="formatText('italic'); close()">
          <icon type="italic" /> 斜体
        </div>
        <div class="menu-item" @click="formatText('underline'); close()">
          <icon type="underline" /> 下划线
        </div>
        <div class="divider"></div>
        <div class="menu-item" @click="copyText(); close()">
          <icon type="copy" /> 复制
        </div>
        <div class="menu-item" @click="pasteText(); close()">
          <icon type="paste" /> 粘贴
        </div>
      </template>
    </context-menu>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import ContextMenu from './ContextMenu.vue'
import Icon from './Icon.vue'

const content = ref('右键点击此处显示上下文菜单...')

function formatText(format) {
  document.execCommand(format, false, null)
}

function copyText() {
  document.execCommand('copy')
}

function pasteText() {
  document.execCommand('paste')
}
</script>
```

## 9. Vue 3插槽性能优化

### 9.1 编译时优化

Vue 3的编译器对插槽进行了多项优化：

1. **静态插槽提升**：静态的插槽内容会在编译时被提升，避免在渲染时重复创建
2. **Block Tree**：Vue 3引入的Block Tree机制可以更精确地跟踪动态节点，减少不必要的更新
3. **PatchFlag**：编译器会为插槽内容添加PatchFlag，指示运行时如何高效地更新内容

### 9.2 运行时优化

1. **懒执行**：插槽函数只在实际需要时才会被执行
2. **缓存**：插槽的渲染结果会被缓存，避免不必要的重新渲染
3. **更精确的更新**：插槽内容的更新不会触发整个组件树的重新渲染

### 9.3 性能优化建议

1. **避免不必要的作用域插槽**：只在需要从子组件获取数据时使用作用域插槽
2. **使用v-memo优化**：对于复杂的插槽内容，可以使用`v-memo`指令避免不必要的重新渲染

```vue
<template>
  <my-component>
    <template #item="{ item }">
      <!-- 只有当item.id变化时才会重新渲染 -->
      <div v-memo="[item.id]">
        <complex-item-renderer :item="item" />
      </div>
    </template>
  </my-component>
</template>
```

3. **合理使用shallowRef**：对于不需要深度响应式的插槽数据，可以使用`shallowRef`提高性能

## 10. 实际应用场景

### 10.1 数据表格组件

```vue
<!-- DataTable.vue -->
<template>
  <table class="data-table">
    <thead>
      <tr>
        <th v-for="column in columns" :key="column.key">
          <!-- 表头插槽 -->
          <slot :name="`header-${column.key}`" :column="column">
            {{ column.title }}
          </slot>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="(row, rowIndex) in data" :key="rowIndex">
        <td v-for="column in columns" :key="column.key">
          <!-- 单元格插槽 -->
          <slot :name="`cell-${column.key}`" :row="row" :column="column" :index="rowIndex">
            {{ row[column.key] }}
          </slot>
        </td>
      </tr>
    </tbody>
    <tfoot v-if="$slots.footer">
      <tr>
        <td :colspan="columns.length">
          <!-- 表尾插槽 -->
          <slot name="footer" :data="data"></slot>
        </td>
      </tr>
    </tfoot>
  </table>
</template>

<script setup>
defineProps({
  columns: Array,
  data: Array
})
</script>
```

使用示例：

```vue
<template>
  <data-table :columns="columns" :data="users">
    <!-- 自定义表头 -->
    <template #header-actions="{ column }">
      <div class="header-actions">{{ column.title }}</div>
    </template>

    <!-- 自定义单元格 -->
    <template #cell-name="{ row }">
      <div class="user-name">
        <avatar :src="row.avatar" />
        {{ row.name }}
      </div>
    </template>

    <template #cell-actions="{ row }">
      <button @click="editUser(row)">编辑</button>
      <button @click="deleteUser(row)">删除</button>
    </template>

    <!-- 表尾 -->
    <template #footer="{ data }">
      <div class="table-summary">
        共 {{ data.length }} 条记录
      </div>
    </template>
  </data-table>
</template>

<script setup>
import { ref } from 'vue'

const columns = [
  { key: 'name', title: '用户名' },
  { key: 'email', title: '邮箱' },
  { key: 'role', title: '角色' },
  { key: 'actions', title: '操作' }
]

const users = ref([
  { id: 1, name: '张三', email: 'zhangsan@example.com', role: '管理员', avatar: '/avatars/1.png' },
  { id: 2, name: '李四', email: 'lisi@example.com', role: '编辑', avatar: '/avatars/2.png' }
])

function editUser(user) {
  // 编辑用户
}

function deleteUser(user) {
  // 删除用户
}
</script>
```

### 10.2 表单组件

```vue
<!-- FormItem.vue -->
<template>
  <div class="form-item" :class="{ 'has-error': error }">
    <label v-if="label || $slots.label" class="form-label">
      <slot name="label">{{ label }}</slot>
      <span v-if="required" class="required-mark">*</span>
    </label>

    <div class="form-control">
      <slot></slot>
    </div>

    <div v-if="error || $slots.error" class="form-error">
      <slot name="error">{{ error }}</slot>
    </div>

    <div v-if="$slots.help" class="form-help">
      <slot name="help"></slot>
    </div>
  </div>
</template>

<script setup>
defineProps({
  label: String,
  required: Boolean,
  error: String
})
</script>
```

使用示例：

```vue
<template>
  <form @submit.prevent="submitForm">
    <form-item 
      label="用户名" 
      required 
      :error="errors.username"
    >
      <input 
        v-model="form.username" 
        type="text" 
        placeholder="请输入用户名"
      />

      <template #help>
        <span>用户名长度应为3-20个字符</span>
      </template>
    </form-item>

    <form-item>
      <template #label>
        <span class="custom-label">密码强度</span>
      </template>

      <password-strength-meter :value="form.password" />
    </form-item>

    <button type="submit">提交</button>
  </form>
</template>

<script setup>
import { reactive } from 'vue'

const form = reactive({
  username: '',
  password: ''
})

const errors = reactive({
  username: '',
  password: ''
})

function submitForm() {
  // 表单验证和提交逻辑
}
</script>
```

## 11. 总结

插槽是Vue组件系统中非常重要的一部分，它使得组件更加灵活和可复用。通过合理使用默认插槽、具名插槽和作用域插槽，可以构建出高度可定制的组件。

- **默认插槽**：最基本的内容分发机制
- **具名插槽**：允许多个插槽位置
- **作用域插槽**：允许子组件向父组件传递数据

Vue 3在插槽实现上进行了全面优化：

1. **统一的插槽模型**：简化了内部实现
2. **更高效的更新机制**：减少不必要的重新渲染
3. **Composition API支持**：提供了新的使用方式
4. **与新特性结合**：可以与Teleport、Suspense等新特性结合使用

理解插槽的底层实现原理有助于更好地使用插槽，并在必要时进行性能优化。在Vue的版本迭代中，插槽语法和实现都有所变化，但核心理念保持不变：提供一种灵活的内容分发机制，增强组件的可复用性和可定制性。
