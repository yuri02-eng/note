# JavaScript 闭包详解笔记

## 一、闭包的基本概念

### 1.1 定义
**闭包（Closure）** 是指能够访问并记住其词法作用域中变量的函数，即使函数在其词法作用域之外执行。

### 1.2 核心特征
- 函数嵌套函数
- 内部函数可以访问外部函数的变量和参数
- 外部函数的变量在函数执行完毕后仍然保持在内存中

## 二、闭包的形成原理

### 2.1 作用域链机制
JavaScript采用词法作用域（静态作用域），函数的作用域在函数定义时确定：
```javascript
function outer() {
    var outerVar = "外部变量";
    
    function inner() {
        console.log(outerVar); // 可以访问outerVar
    }
    
    return inner;
}

var closureFunc = outer();
closureFunc(); // "外部变量"
```

### 2.2 变量保持机制
闭包使外部函数的变量在函数执行完毕后不被垃圾回收：
```javascript
function createCounter() {
    let count = 0; // 这个变量会被闭包"记住"
    
    return function() {
        return ++count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

## 三、闭包的主要用途

### 3.1 数据封装与私有变量
```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance; // 私有变量
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return "余额不足";
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
console.log(account.getBalance()); // 100
account.deposit(50);
console.log(account.getBalance()); // 150
```

### 3.2 模块化开发
```javascript
var MyModule = (function() {
    var privateData = "私有数据";
    
    function privateMethod() {
        console.log("私有方法: " + privateData);
    }
    
    return {
        publicMethod: function() {
            privateMethod();
        },
        setData: function(data) {
            privateData = data;
        }
    };
})();

MyModule.publicMethod(); // "私有方法: 私有数据"
MyModule.setData("新数据");
MyModule.publicMethod(); // "私有方法: 新数据"
```

### 3.3 函数工厂与柯里化
```javascript
// 函数工厂
function createMultiplier(factor) {
    return function(value) {
        return value * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// 柯里化
function curryAdd(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

const add5 = curryAdd(5);
const add5And3 = add5(3);
console.log(add5And3(2)); // 10
```

### 3.4 事件处理与回调
```javascript
// 解决循环中的闭包问题
function setupButtons() {
    for (var i = 0; i < 5; i++) {
        (function(index) {
            document.getElementById(`btn-${index}`).addEventListener('click', function() {
                console.log(`按钮 ${index} 被点击`);
            });
        })(i);
    }
}

// 使用let的现代写法
function setupButtonsModern() {
    for (let i = 0; i < 5; i++) {
        document.getElementById(`btn-${i}`).addEventListener('click', function() {
            console.log(`按钮 ${i} 被点击`);
        });
    }
}
```

## 四、闭包的优缺点

### 4.1 优点
1. **数据封装**：创建私有变量和方法
2. **状态保持**：函数可以"记住"之前的执行上下文
3. **模块化**：实现模块模式和命名空间
4. **灵活性**：支持函数工厂和柯里化等高阶函数模式

### 4.2 缺点
1. **内存消耗**：闭包会保持对外部变量的引用，可能导致内存无法释放
2. **性能影响**：访问外部变量比访问局部变量稍慢
3. **潜在内存泄漏**：不当使用可能导致内存泄漏

## 五、闭包与内存管理

### 5.1 内存泄漏风险
```javascript
// 可能造成内存泄漏的例子
function createHeavyClosure() {
    var largeData = new Array(1000000).fill('data');
    
    return function() {
        console.log('数据大小: ' + largeData.length);
    };
}

var heavyFunction = createHeavyClosure();
// largeData不会被回收，即使createHeavyClosure已执行完毕
```

### 5.2 避免内存泄漏
```javascript
// 正确做法：不再需要时解除引用
function processData() {
    var largeData = new Array(1000000).fill('data');
    
    return function() {
        console.log('处理数据: ' + largeData.length);
    };
}

var dataProcessor = processData();
dataProcessor(); // 使用闭包

// 不再需要时
dataProcessor = null; // 解除引用，允许垃圾回收
```

## 六、现代JavaScript中的闭包

### 6.1 使用let和const
ES6的块级作用域变量使闭包更直观：
```javascript
// 使用var的问题
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出3次3
    }, 100);
}

// 使用let解决
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出0,1,2
    }, 100);
}
```

### 6.2 箭头函数与闭包
箭头函数提供更简洁的闭包写法：
```javascript
const createAdder = base => value => base + value;

const add10 = createAdder(10);
console.log(add10(5)); // 15
```

## 七、最佳实践与注意事项

### 7.1 最佳实践
1. **明确闭包用途**：只在需要时使用闭包
2. **避免不必要的闭包**：简单功能不需要闭包
3. **及时释放资源**：不再需要的闭包应及时解除引用
4. **使用模块模式**：合理组织代码结构

### 7.2 常见陷阱
1. **循环中的闭包问题**：
```javascript
// 错误示例
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i); // 全部输出5
    }, 100);
}

// 解决方案：使用IIFE或let
for (var i = 0; i < 5; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j); // 输出0,1,2,3,4
        }, 100);
    })(i);
}
```

2. **意外的全局变量**：
```javascript
function createClosure() {
    // 忘记使用var/let/const，意外创建全局变量
    value = "意外全局变量";
    
    return function() {
        console.log(value);
    };
}
```

## 八、总结

闭包是JavaScript中强大且重要的特性，它允许函数：
- 访问并记住其词法作用域中的变量
- 创建私有变量和函数，实现数据封装
- 支持高阶函数和函数式编程模式

正确理解和使用闭包对于编写高质量JavaScript代码至关重要，但同时也要注意内存管理和性能优化。

**关键要点：**
- 闭包是函数和其词法环境的组合
- 合理使用闭包可以实现模块化、数据封装和高阶函数
- 注意闭包可能导致的内存泄漏问题
- 现代JavaScript中，使用let/const和箭头函数可以使闭包更清晰