# JavaScript 高阶函数与柯里化完全指南

## 一、高阶函数（Higher-Order Functions）

### 1. 什么是高阶函数？

**高阶函数**是指满足以下任一条件的函数：
- 接受一个或多个函数作为参数
- 返回一个函数作为结果

高阶函数是函数式编程的核心概念，它们可以抽象控制流，增加代码复用性，并提高代码的表达能力。

### 2. 常见高阶函数实现

#### 🔹 once函数（只执行一次）
```javascript
function once(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  };
}

// 使用示例
const initialize = once(() => {
  console.log('Initialized!');
  return 'done';
});

initialize(); // "Initialized!"
initialize(); // (无输出，但返回'done')
```

#### 🔹 debounce函数（防抖）
```javascript
function debounce(fn, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用示例：搜索建议
const searchSuggestions = debounce((query) => {
  console.log(`Searching for: ${query}`);
}, 300);
```

#### 🔹 throttle函数（节流）
```javascript
function throttle(fn, interval) {
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}

// 使用示例：滚动事件
const handleScroll = throttle(() => {
  console.log('Handling scroll');
}, 200);
```

```javascript
function throttle(fn, delay) {
    let flag = true;
    return function (...args) {
        if (!flag) {
            return;
        }
        flag = false;
        setTimeout(() => {
            fn.apply(this, args);
            flag = true;
        }, delay);
    };
}
```

## 两种实现的区别

| 特性         | 时间戳方式   | 定时器方式 |
| ------------ | ------------ | ---------- |
| 首次调用     | 立即执行     | 延迟执行   |
| 最后一次调用 | 可能不会执行 | 保证会执行 |
| 执行时机     | 间隔开始时   | 间隔结束时 |
| 实现方式     | 比较时间戳   | 使用定时器 |

## 实际应用场景

- **时间戳方式**适合需要立即响应的场景（如按钮点击）
- **定时器方式**适合需要保证最后一次操作被执行的情况（如滚动加载）

两种都是有效的节流实现，选择哪种取决于你的具体需求。

### 3. 高阶函数的应用场景

| 函数类型 | 应用场景 | 核心思想 |
|---------|---------|---------|
| **once** | 初始化操作、单次事件绑定 | 确保函数只执行一次 |
| **debounce** | 搜索输入、窗口调整、实时保存 | 等待操作停止后执行 |
| **throttle** | 滚动事件、鼠标移动、频繁点击 | 固定时间间隔执行 |

## 二、柯里化（Currying）

### 1. 什么是柯里化？

柯里化是将多参数函数转换为一系列单参数函数的技术。柯里化后的函数每次只接受一个参数，并返回一个新函数来接受下一个参数。

### 2. 柯里化实现

对于实现的理解

```javascript
function curry(fn, ...args) {
    return function () {
        let _args = [...args, ...arguments];
        let len = fn.length;
        
        if (_args.length < len) {
            return curry(fn, ..._args);
        } else {
            return fn.apply(this, _args);
        }
    };
}
```



这个柯里化(curry)函数的核心机制就是：**每次调用都返回一个新的函数，这个新函数会合并之前收集的参数和当前传入的参数**。

让我详细解释这个过程：

## 工作流程分解

```
function curry(fn, ...args) {
    return function () {
        let _args = [...args, ...arguments];  // 合并参数
        // ... 其他逻辑
    };
}
```

## 具体步骤

1. **首次调用**：`curry(sum)`→ 返回一个新函数，内部保存 `args = []`
2. **第一次参数传入**：`curriedSum(1)`→
   - 合并参数：`_args = [1]`
   - 参数不足 → 返回 `curry(sum, 1)`（另一个新函数）
3. **第二次参数传入**：`curriedSum(1)(2)`→
   - 合并参数：`_args = [1, 2]`
   - 参数仍不足 → 返回 `curry(sum, 1, 2)`（又一个新函数）
4. **参数足够时**：`curriedSum(1)(2)(3)`→
   - 合并参数：`_args = [1, 2, 3]`
   - 参数足够 → 执行原函数 `sum.apply(this, [1, 2, 3])`

## 关键特性

- **参数累积**：每次调用都会将新参数与已有参数合并
- **闭包机制**：每个返回的函数都记住了当前收集到的参数
- **递归返回**：参数不足时继续返回柯里化函数，形成链式调用
- **延迟执行**：只有在参数足够时才真正执行原函数

## 所以：

**"相当于每次返回一个合并参数的柯里化函数"** — 这正是柯里化实现的精髓！

每次调用都返回一个新的函数，这个函数：

1. 记住了之前所有传入的参数
2. 等待接收更多参数
3. 在参数足够时执行原函数

这种设计使得柯里化非常灵活，支持多种调用方式，如：

- `curriedSum(1)(2)(3)`
- `curriedSum(1, 2)(3)`
- `curriedSum(1)(2, 3)`

#### 基础实现
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
```

#### 支持占位符的高级实现
```javascript
function advancedCurry(fn) {
  const placeholder = Symbol('placeholder');
  
  function curried(...args) {
    const actualArgs = args.filter(arg => arg !== placeholder);
    
    if (actualArgs.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return function(...nextArgs) {
      const combinedArgs = args.map(arg => 
        arg === placeholder && nextArgs.length ? 
        nextArgs.shift() : arg
      ).concat(nextArgs);
      
      return curried.apply(this, combinedArgs);
    };
  }
  
  curried.placeholder = placeholder;
  return curried;
}

// 使用示例
const _ = advancedCurry.placeholder;
const add = advancedCurry((a, b, c) => a + b + c);

console.log(add(1, _, 3)(2)); // 6
```

### 3. 柯里化的实际价值

```javascript
// 1. 参数复用
const createURL = curry((protocol, domain, path) => 
  `${protocol}://${domain}/${path}`
);

const createAPI = createURL('https')('api.example.com');
console.log(createAPI('users')); // https://api.example.com/users

// 2. 延迟执行
const fetchData = curry((method, endpoint, data) => {
  // API调用逻辑
});

const postUser = fetchData('POST')('users');
// 稍后调用：postUser(userData);

// 3. 函数组合
const filter = curry((predicate, array) => array.filter(predicate));
const map = curry((transform, array) => array.map(transform));

const processData = pipe(
  filter(x => x > 2),
  map(x => x * 2)
);
```

## 三、函数式编程库特性

### 1. Lodash/FP 特性

Lodash/FP 是 Lodash 的函数式编程版本，提供自动柯里化和不可变操作。

```javascript
import _ from 'lodash';
import fp from 'lodash/fp';

// 传统Lodash
_.map([1, 2, 3], x => x * 2);

// Lodash/FP (自动柯里化，数据最后)
const doubleAll = fp.map(x => x * 2);
const result = doubleAll([1, 2, 3]); // [2, 4, 6]

// 函数组合
const processData = fp.pipe(
  fp.filter(x => x > 1),
  fp.map(x => x * 2),
  fp.take(2)
);
```

### 2. Ramda 特性

Ramda 是专为函数式编程设计的库，所有函数都自动柯里化。

```javascript
const R = require('ramda');

// 自动柯里化
const add = R.add;
const multiply = R.multiply;

// 函数组合
const transform = R.pipe(
  R.filter(R.gt(R.__, 2)),    // 大于2
  R.map(R.multiply(2)),       // 乘以2
  R.take(3)                   // 取前3个
);

// 镜头(Lenses) - 不可变数据操作
const userLens = R.lensProp('user');
const nameLens = R.lensPath(['user', 'name']);
```

### 3. 两库对比

| 特性 | Lodash/FP | Ramda |
|------|-----------|-------|
| **设计目标** | 为现有用户提供FP版本 | 纯粹的FP库 |
| **学习曲线** | 较低 | 较陡峭 |
| **性能** | 优化过的生产环境性能 | 纯函数性能 |
| **适用场景** | 渐进式迁移到FP | 纯FP项目 |

## 四、面试准备指南

### 1. 高频面试题

#### 💡 实现 debounce 函数
```javascript
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

#### 💡 实现 throttle 函数
```javascript
function throttle(fn, interval) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

#### 💡 实现通用 curry 函数
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}
```

### 2. 面试问题解析

**Q: 柯里化有什么好处？**
A: 参数复用、延迟执行、函数组合便利、提高代码可读性

**Q: debounce 和 throttle 有什么区别？**
A: debounce 等待操作停止后执行，throttle 按固定频率执行

**Q: Lodash 和 Ramda 的主要区别是什么？**
A: Lodash/FP 是 Lodash 的 FP 适配版本，Ramda 是原生 FP 库，设计哲学和参数顺序不同

## 五、实际应用案例

### 1. API 请求构建
```javascript
const createRequest = curry((method, baseUrl, endpoint, data) => {
  return fetch(`${baseUrl}/${endpoint}`, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
});

const apiRequest = createRequest('POST')('https://api.example.com');
const createUser = apiRequest('users');
```

### 2. 数据验证管道
```javascript
const validate = curry((validator, value) => validator(value));
const isRequired = validate(value => !!value);
const minLength = min => validate(value => value.length >= min);

const validateUser = pipe(
  isRequired,
  minLength(3)
);
```

### 3. React 高阶组件
```javascript
const withFeature = curry((feature, Component) => {
  return function EnhancedComponent(props) {
    const featureData = useFeature(feature);
    return <Component {...props} {...featureData} />;
  };
});

const withAuth = withFeature('auth');
```

## 总结

高阶函数和柯里化是函数式编程的核心概念，掌握这些技术可以：

1. **提高代码质量**：通过抽象和复用减少重复代码
2. **增强表达能力**：使代码更加声明式和表达意图
3. **便于测试和维护**：纯函数和柯里化使代码更易测试
4. **应对面试挑战**：掌握常见高阶函数的实现和理解FP库的特性

通过深入理解 once、debounce、throttle 的实现原理，掌握通用 curry 函数的编写技巧，以及熟悉主流 FP 库的特性差异，你将能够写出更加健壮和可维护的 JavaScript 代码。