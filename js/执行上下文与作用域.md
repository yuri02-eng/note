# JavaScript 执行上下文与作用域链完整指南

部分内容与词法作用域重叠

## 一、执行上下文（Execution Context）

### 1. 什么是执行上下文？

执行上下文是 JavaScript 代码执行时的环境，它包含了变量、函数、参数、this 指向等信息。每当代码执行时，都会在一个特定的执行上下文中运行。

### 2. 执行上下文的类型

- **全局执行上下文**：代码首次执行时的默认环境，一个程序中只有一个全局执行上下文
- **函数执行上下文**：每次函数调用都会创建一个新的函数执行上下文
- **Eval 函数执行上下文**：在 `eval` 函数内部执行的代码也会获得自己的执行上下文（不常用且不建议使用）

### 3. 执行上下文的生命周期

每个执行上下文都经历两个阶段：

#### 创建阶段（变量对象创建）
1. 创建变量对象（Variable Object）
2. 建立作用域链（Scope Chain）
3. 确定 `this` 的指向

#### 执行阶段（代码执行）
1. 变量赋值
2. 函数引用
3. 执行代码

### 4. 变量对象（Variable Object）

变量对象包含以下内容：
- 函数形参（函数执行上下文）
- 函数声明（Function Declaration）
- 变量声明（Variable Declaration，包括 var 声明的变量，初始值为 undefined）

注意：函数执行上下文的变量对象也被称为活动对象（Activation Object）。

### 5. 变量提升（Hoisting）

变量提升是执行上下文创建阶段的结果：
- 函数声明完全提升（包括函数体）
- var 声明的变量只提升声明，不提升赋值
- let 和 const 声明的变量存在暂时性死区（TDZ），不会提升

```javascript
console.log(a); // undefined (变量提升)
var a = 10;

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;

foo(); // "Hello" (函数提升)
function foo() {
  console.log("Hello");
}
```

### 6. 执行上下文栈（Execution Context Stack）

JavaScript 引擎使用栈来管理执行上下文，也称为调用栈（Call Stack）。

- 当代码开始执行时，全局执行上下文被压入栈底
- 每当函数被调用，新的函数执行上下文被压入栈顶
- 当函数执行完毕，其执行上下文从栈中弹出
- 栈顶的执行上下文是当前正在执行的上下文

```javascript
function func1() {
  func2();
}

function func2() {
  func3();
}

function func3() {
  console.log("Inside func3");
}

func1();

// 执行上下文栈的变化：
// 1. 全局上下文入栈
// 2. 调用func1，func1上下文入栈
// 3. 在func1中调用func2，func2上下文入栈
// 4. 在func2中调用func3，func3上下文入栈
// 5. func3执行完毕，出栈
// 6. func2执行完毕，出栈
// 7. func1执行完毕，出栈
// 8. 全局上下文在程序结束时出栈
```

## 二、作用域（Scope）

### 1. 什么是作用域？

作用域是变量和函数的可访问范围，即作用域控制着变量和函数的可见性与生命周期。

### 2. 作用域的类型

- **全局作用域**：在代码任何地方都能访问
- **函数作用域**：在函数内部声明的变量只能在函数内部访问
- **块级作用域**（ES6引入）：使用 `let` 和 `const` 声明的变量具有块级作用域，只能在声明它们的块（如 {}）内访问

### 3. 词法作用域（静态作用域）

JavaScript 采用词法作用域，即函数的作用域在函数定义时就确定了，而不是在函数调用时。

```javascript
var a = 10;

function outer() {
  var a = 20;
  
  function inner() {
    console.log(a); // 20 (词法作用域，在定义时确定访问outer的a)
  }
  
  return inner;
}

var innerFunc = outer();
innerFunc(); // 20
```

## 三、作用域链（Scope Chain）

### 1. 什么是作用域链？

当代码在一个上下文中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行上下文有权访问的变量和函数的有序访问。

### 2. 作用域链的创建

- 函数定义时，会保存其外部作用域的作用域链
- 函数被调用时，会创建新的执行上下文，并将该函数的活动对象添加到作用域链的前端
- 作用域链的前端是当前执行上下文的变量对象，下一个变量对象来自包含（外部）环境，再下一个来自更外部的环境，直到全局上下文

```javascript
// 词法作用域示例
var x = 10;

function foo() {
  console.log(x); // 总是访问全局的x，与调用方式无关
}

function bar() {
  var x = 20;
  foo(); // 输出10，而不是20
}

bar();
```

### 3、作用域链的创建过程

#### 1. 函数定义阶段：记录外部引用

当函数被定义时，它会**保存对其外部词法环境的引用**，这个引用就是函数的作用域链基础。

```javascript
var globalVar = 'global';

function outer() {
  var outerVar = 'outer';
  
  // inner函数定义时，会记录outer的作用域作为其外部引用
  function inner() {
    var innerVar = 'inner';
    console.log(innerVar, outerVar, globalVar);
  }
  
  return inner;
}
```

#### 2. 函数调用阶段：构建完整作用域链

当函数被调用时，JavaScript 引擎会：
1. 创建函数的执行上下文
2. 创建活动对象（包含参数、局部变量等）
3. 将活动对象添加到作用域链的前端
4. 将函数定义时保存的外部引用作为作用域链的后续部分

```javascript
var globalVar = 'global';

function outer() {
  var outerVar = 'outer';
  
  function inner() {
    var innerVar = 'inner';
    console.log(innerVar, outerVar, globalVar);
  }
  
  return inner;
}

var innerFunc = outer();
innerFunc(); // 输出: inner outer global

// inner函数执行时的作用域链：
// [inner的活动对象] -> [outer的活动对象] -> [全局变量对象]
```

### 4、内部实现原理：[[Environment]] 属性

从 ECMAScript 规范的角度，每个函数都有一个内部属性 `[[Environment]]`，它在函数创建时被设置，指向函数被定义时的词法环境。

#### 1. 函数创建时

```javascript
var x = 10;

function foo() {
  var y = 20;
  
  // bar函数创建时，其[[Environment]]指向foo的执行环境
  function bar() {
    console.log(x, y);
  }
  
  return bar;
}
```

#### 2. 函数调用时

当函数被调用时，会创建一个新的词法环境，其外部引用（outer reference）指向函数的 `[[Environment]]` 属性值。

```javascript
var barFunc = foo();
barFunc(); // 输出: 10 20

// bar函数调用时的环境关系：
// bar的词法环境 -> foo的词法环境 -> 全局词法环境
```

### 5、变量查找的具体过程

当访问一个变量时，JavaScript 引擎会沿着作用域链逐级查找：

```javascript
var globalVar = 'global';

function level1() {
  var level1Var = 'level1';
  
  function level2() {
    var level2Var = 'level2';
    
    function level3() {
      var level3Var = 'level3';
      
      // 变量查找过程：
      console.log(level3Var); // 1. 在当前作用域找到
      console.log(level2Var); // 2. 在level2作用域找到
      console.log(level1Var); // 3. 在level1作用域找到
      console.log(globalVar); // 4. 在全局作用域找到
      console.log(undefinedVar); // 5. 抛出ReferenceError
    }
    
    level3();
  }
  
  level2();
}

level1();
```

### 6、引擎内部的实现机制

虽然具体实现因 JavaScript 引擎而异，但基本原理类似：

#### 1) 环境记录（Environment Record）
每个执行上下文都有一个环境记录，用于存储变量和函数声明。

#### 2) 外部环境引用（Outer Environment Reference）
每个环境记录都有一个指向外部环境的引用，形成作用域链。

#### 3) 变量解析算法
当需要解析一个标识符时：
1. 检查当前环境记录中是否存在该标识符
2. 如果存在，返回对应的值
3. 如果不存在，沿着外部环境引用链向上查找
4. 如果到达全局环境仍未找到，抛出 ReferenceError

```javascript
// 伪代码表示变量查找过程
function resolveIdentifier(identifier, currentEnvironment) {
  while (currentEnvironment !== null) {
    if (currentEnvironment.hasBinding(identifier)) {
      return currentEnvironment.getBindingValue(identifier);
    }
    currentEnvironment = currentEnvironment.outer;
  }
  throw new ReferenceError(identifier + " is not defined");
}
```

### 7. 变量查找机制

当需要访问变量时，会从作用域链的前端开始查找，直到找到标识符或到达全局作用域（如果全局作用域也没有，则报错）。

```javascript
var globalVar = 'global';

function outer() {
  var outerVar = 'outer';
  
  function inner() {
    var innerVar = 'inner';
    console.log(innerVar);   // 在当前作用域找到
    console.log(outerVar);   // 在outer作用域找到
    console.log(globalVar);  // 在全局作用域找到
    console.log(undefinedVar); // ReferenceError
  }
  
  inner();
}

outer();
```

## 四、ES6 中的 let 和 const

### 1. 块级作用域

`let` 和 `const` 声明的变量具有块级作用域，只在声明它们的块内有效。

```javascript
if (true) {
  var varVariable = 'var';
  let letVariable = 'let';
  const constVariable = 'const';
}

console.log(varVariable); // 'var' (函数作用域)
console.log(letVariable); // ReferenceError
console.log(constVariable); // ReferenceError
```

### 2. 暂时性死区（Temporal Dead Zone）

在块级作用域中，使用 `let` 或 `const` 声明的变量在声明之前不可访问，否则会抛出错误。

```javascript
console.log(a); // undefined (变量提升)
var a = 10;

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;
```

### 3. 循环中的块级作用域

在循环中使用 `let` 声明变量，每次迭代都会创建一个新的变量绑定。

```javascript
// var 声明的问题
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 输出3次3
  }, 1000);
}

// let 声明的解决方案
for (let j = 0; j < 3; j++) {
  setTimeout(function() {
    console.log(j); // 输出0, 1, 2
  }, 1000);
}
```

## 五、this 关键字

### 1. this 的绑定规则

- **默认绑定**：在普通函数调用中，`this` 指向全局对象（浏览器中为 window，严格模式下为 undefined）
- **隐式绑定**：作为对象方法调用时，`this` 指向调用该方法的对象
- **显式绑定**：使用 `call()`, `apply()`, `bind()` 方法显式指定 `this`
- **new 绑定**：使用 `new` 关键字调用构造函数时，`this` 指向新创建的对象

```javascript
// 默认绑定
function showThis() {
  console.log(this);
}
showThis(); // Window (非严格模式)

// 隐式绑定
const obj = {
  value: 42,
  getValue: function() {
    return this.value;
  }
};
console.log(obj.getValue()); // 42

// 显式绑定
function greet() {
  console.log(`Hello, ${this.name}`);
}
const person = { name: 'John' };
greet.call(person); // Hello, John

// new 绑定
function Person(name) {
  this.name = name;
}
const john = new Person('John');
console.log(john.name); // John
```

### 2. 箭头函数的 this

箭头函数没有自己的 `this`，它继承自外层函数或全局作用域。

```javascript
const obj = {
  value: 42,
  regularFunction: function() {
    console.log(this.value); // 42
  },
  arrowFunction: () => {
    console.log(this.value); // undefined (继承自全局作用域)
  }
};

obj.regularFunction();
obj.arrowFunction();
```

## 六、总结与最佳实践

### 1. 关键概念总结

- **执行上下文**：代码执行的环境，包括变量对象、作用域链和 this 绑定
- **作用域**：变量和函数的可访问范围
- **作用域链**：变量查找的机制，基于词法作用域
- **闭包**：函数和其相关引用环境的组合
- **this 绑定**：函数的执行上下文，取决于调用方式

### 2. 最佳实践

1. **优先使用 let 和 const**：避免变量提升和全局污染
2. **理解闭包的使用**：合理使用闭包，注意内存泄漏问题
3. **明确 this 的指向**：在需要时使用 `call`, `apply`, `bind` 或箭头函数
4. **避免过度嵌套**：减少作用域链的长度，提高代码可读性
5. **使用模块模式**：封装私有变量和方法

### 3. 常见问题与解决方案

```javascript
// 问题：循环中的异步回调
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出5次5
  }, 100);
}

// 解决方案1：使用let
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出0,1,2,3,4
  }, 100);
}

// 解决方案2：使用IIFE
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j); // 输出0,1,2,3,4
    }, 100);
  })(i);
}

// 问题：方法中的this丢失
const obj = {
  value: 42,
  getValue: function() {
    return this.value;
  }
};

const getValue = obj.getValue;
console.log(getValue()); // undefined (this指向全局)

// 解决方案：使用bind
const boundGetValue = obj.getValue.bind(obj);
console.log(boundGetValue()); // 42
```

理解执行上下文和作用域链对于掌握 JavaScript 的核心概念至关重要，它们是理解变量提升、闭包、this 指向等高级主题的基础。通过合理运用这些概念，可以写出更加健壮和可维护的 JavaScript 代码。