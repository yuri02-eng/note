# JavaScript 词法作用域详解

## 一、基本概念

### 1.1 什么是词法作用域？
**词法作用域（Lexical Scoping）**，也称为静态作用域，是指变量的作用域在代码编写时（词法分析阶段）就已经确定，而不是在代码执行时确定。

### 1.2 核心特征
- 作用域由代码书写的位置决定
- 函数的作用域在函数定义时就已经确定
- 内部函数可以访问外部函数的变量和参数

## 二、词法作用域 vs 动态作用域

### 2.1 词法作用域（JavaScript采用）
```javascript
var x = 10;

function foo() {
    console.log(x);
}

function bar() {
    var x = 20;
    foo(); // 输出10，而不是20
}

bar();
```
在词法作用域中，`foo`函数访问的是它定义时所在作用域的`x`变量（全局的`x=10`）。

你的代码中，`foo()` 输出的是 10，而不是 20。这是因为 JavaScript 采用**词法作用域**（lexical scoping），也称为静态作用域。让我详细解释一下为什么会出现这种情况。

### 代码分析
```javascript
var x = 10; // 全局变量 x

function foo() {
    console.log(x); // 这里访问的是全局变量 x
}

function bar() {
    var x = 20; // 局部变量 x，只在 bar 函数内部可见
    foo(); // 调用 foo 函数
}

bar(); // 输出 10
```

### 为什么输出 10？
1. **词法作用域规则**：JavaScript 的作用域在函数**定义时**就已经确定，而不是在函数调用时。也就是说，函数的作用域基于它被声明的位置，而不是它被调用的位置。
   - 函数 `foo` 是在全局作用域中定义的，因此它的作用域链包括：
     - 它自身的作用域（没有局部变量 `x`）。
     - 全局作用域（其中 `x = 10`）。
   - 当 `foo` 内部访问 `x` 时，JavaScript 会沿着作用域链查找，首先在 `foo` 内部找不到 `x`，然后在全局作用域中找到 `x = 10`。
2. **`bar` 函数中的 `x` 是局部变量**：在 `bar` 函数内部声明的 `var x = 20` 是一个局部变量，只在 `bar` 函数内部可见。它不会影响全局变量 `x`，也不会影响 `foo` 函数的作用域链。因此，当 `foo` 被调用时，它根本看不到 `bar` 中的 `x`。
3. **执行过程**：
   - 调用 `bar()`。
   - `bar` 内部设置局部变量 `x = 20`。
   - `bar` 调用 `foo()`。
   - `foo` 开始执行，并尝试读取 `x`。
   - `foo` 的作用域链决定了它只能访问全局 `x`（值为 10），所以输出 10。

JavaScript使用作用域链来解析变量，查找顺序为：

1. 当前函数作用域 foo内部没有x这个变量
2. 外层函数作用域  没有外层函数
3. 全局作用域  全局有x=20

### 2.2 动态作用域（JavaScript不采用）

如果JavaScript采用动态作用域，上面的例子中`foo()`会输出20，因为它会在调用它的函数`bar`的作用域中查找`x`。

## 三、词法作用域的工作原理

### 3.1 作用域链
JavaScript使用作用域链来解析变量，查找顺序为：
1. 当前函数作用域
2. 外层函数作用域
3. 全局作用域

```javascript
var globalVar = "全局变量";

function outer() {
    var outerVar = "外部变量";
    
    function inner() {
        var innerVar = "内部变量";
        console.log(innerVar); // 内部变量（当前作用域）
        console.log(outerVar); // 外部变量（外层作用域）
        console.log(globalVar); // 全局变量（全局作用域）
    }
    
    inner();
}

outer();
```

### 3.2 变量遮蔽（Variable Shadowing）
当内层作用域有与外层作用域同名的变量时，内层变量会遮蔽外层变量：
```javascript
var x = "全局x";

function test() {
    var x = "局部x";
    console.log(x); // "局部x"（遮蔽了全局x）
}

test();
console.log(x); // "全局x"
```

## 四、词法作用域的实际应用

### 4.1 闭包的基础
词法作用域是闭包能够工作的基础：
```javascript
function createCounter() {
    var count = 0; // 在createCounter的作用域中
    
    return function() {
        return ++count; // 内部函数可以访问外部函数的变量
    };
}

var counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

### 4.2 模块模式
利用词法作用域创建私有变量：
```javascript
var MyModule = (function() {
    var privateVar = "私有数据"; // 私有变量
    
    function privateFunction() {
        console.log("私有方法: " + privateVar);
    }
    
    return {
        publicMethod: function() {
            privateFunction();
        },
        setData: function(data) {
            privateVar = data;
        }
    };
})();

MyModule.publicMethod(); // "私有方法: 私有数据"
MyModule.setData("新数据");
MyModule.publicMethod(); // "私有方法: 新数据"
```

## 五、ES6中的块级作用域

### 5.1 var vs let/const
ES6引入了`let`和`const`，提供了块级作用域：
```javascript
// var的作用域是函数级的
function varExample() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10（var没有块级作用域）
}

// let/const的作用域是块级的
function letExample() {
    if (true) {
        let y = 20;
        const z = 30;
    }
    console.log(y); // ReferenceError: y is not defined
    console.log(z); // ReferenceError: z is not defined
}
```

### 5.2 循环中的块级作用域
```javascript
// 使用var的问题
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出3次3
    }, 100);
}

// 使用let解决
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出0,1,2
    }, 100);
}
```

## 六、词法作用域与this的区别

### 6.1 作用域 vs 执行上下文
- **词法作用域**：在代码编写时确定，决定变量的可访问性
- **this**：在函数调用时确定，指向调用该函数的对象

```javascript
var name = "全局名称";

var obj = {
    name: "对象名称",
    getName: function() {
        // 词法作用域：name指向全局变量
        var printGlobalName = function() {
            console.log(name); // "全局名称"
        };
        
        // this指向当前对象
        var printObjectName = function() {
            console.log(this.name); // "对象名称"
        };
        
        printGlobalName();
        printObjectName.call(this);
    }
};

obj.getName();
```

## 七、常见面试问题

### 7.1 变量提升与词法作用域
```javascript
console.log(x); // undefined（变量提升）
var x = 5;

console.log(y); // ReferenceError: y is not defined（let没有变量提升）
let y = 10;
```

### 7.2 作用域链查找
```javascript
var a = 1;

function test() {
    console.log(a); // undefined（变量提升）
    var a = 2;
    console.log(a); // 2
}

test();
```

## 八、最佳实践

1. **避免全局变量**：尽量减少全局变量的使用，使用模块模式封装代码
2. **使用const和let**：优先使用const，其次使用let，避免使用var
3. **明确作用域**：合理规划函数和块级作用域，避免变量污染
4. **注意闭包内存**：合理使用闭包，避免不必要的内存占用

## 九、总结

词法作用域是JavaScript中一个基础且重要的概念：
- 作用域在代码编写时确定，而不是执行时确定
- 内部函数可以访问外部函数的变量（作用域链）
- 是闭包能够工作的基础机制
- ES6的let和const提供了块级作用域，解决了var的一些问题

理解词法作用域对于掌握JavaScript的变量查找、闭包、模块化等高级特性至关重要，是成为JavaScript高级开发者的必备知识。